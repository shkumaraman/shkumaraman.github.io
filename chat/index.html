---
layout: default
title: "Chat With Strangers"
description: "Chat with strangers in free random chat rooms. Enjoy anonymous text & video chat, group chat, and mobile-friendly fun. A safe Omegle & OmeTV alternative."
---

<style>
:root {
  /* Dark Theme Colors */
  --dark-bg: #121212;
  --dark-header-bg: #181818;
  --dark-header-border: #2a2a2a;
  --dark-chat-bg: #1e1e1e;
  --dark-text: #fff;
  --dark-secondary-text: #aaa;
  --dark-input-bg: #333;
  --dark-input-focus: #444;
  --dark-icon-color: #ccc;
  --dark-icon-hover-bg: rgba(255,255,255,0.1);

  /* Light Theme Colors */
  --light-bg: #f5f5f5;
  --light-header-bg: #ffffff;
  --light-header-border: #e0e0e0;
  --light-chat-bg: #f9f9f9;
  --light-msg-bg: #e9e9e9;
  --light-text: #333;
  --light-secondary-text: #666;
  --light-input-bg: #e0e0e0;
  --light-input-focus: #d0d0d0;
  --light-icon-color: #666;
  --light-icon-hover-bg: rgba(0,0,0,0.05);

  /* Common Colors */
  --skip-btn: #ff4d4d;
  --skip-btn-hover: #ff3333;
  --keyword-bubble: #f1f1f1;
  --keyword-border: #ccc;
  --friend-btn: #4CAF50;
  --friend-btn-hover: #45a049;
}

* {
  box-sizing: border-box;
}

html, body {
  overflow-x: hidden;
}
  
body {
  margin: 0;
  padding: 0;
  font-family: 'Segoe UI', sans-serif;
  background: var(--dark-bg);
  color: var(--dark-text);
  display: flex;
  flex-direction: column;
  height: 100vh;
  transition: background 0.3s, color 0.3s;
}

body.light-mode {
  background: var(--light-bg);
  color: var(--light-text);
}

.app-header {
  position: fixed !important;
  top: 0;
  left: 0;
  width: 100%;
  height: 50px;
  background: var(--dark-header-bg);
  padding: 8px 15px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 15px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.4);
  border-bottom: 1px solid var(--dark-header-border);
  z-index: 10000;
}

.light-mode .app-header {
  background: var(--light-header-bg);
  border-bottom: 1px solid var(--light-header-border);
}

.header-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo {
  height: 40px;
  width: 40px;
  border-radius: 10px;
}

.app-title {
  font-size: 1em;
  color: var(--dark-text);
  margin: 0;
}

.light-mode .app-title {
  color: var(--light-text);
}

.header-toggle {
  background: none;
  border: none;
  color: var(--dark-icon-color);
  font-size: 1.1em;
  cursor: pointer;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.3s;
}
  
.header-toggle:hover {
  background: var(--dark-icon-hover-bg);
}

.light-mode .header-toggle {
  color: var(--light-icon-color);
}

.light-mode .header-toggle:hover {
  background: var(--light-icon-hover-bg);
}

.chat-container {
  display: flex;
  flex-direction: column;
  position: relative;
  padding: 50px 0 0 0; 
}
  
#chatLog {
  padding: 12px;
  overflow-y: auto;
  background: var(--dark-chat-bg);
  display: flex;
  flex-direction: column;
}

.light-mode #chatLog {
  background: var(--light-chat-bg);
}

.msg {
  margin: 5px 0;
  padding: 5px 8px;
  background: var(--light-msg-bg);
  color: var(--light-text);
  border: 1px solid var(--dark-secondary-text);
  border-radius: 15px;
  max-width: 80%;
  word-wrap: break-word;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
  
.me { 
  align-self: flex-end; 
  border-bottom-right-radius: 5px;
}
  
.stranger { 
  align-self: flex-start;
  border-bottom-left-radius: 5px;
}

.timestamp {
  font-size: 0.7em;
  color: var(--dark-secondary-text);
  text-align: right;
}

.chat-controls {
  position: fixed;
  bottom: 0;
  display: flex;
  align-items: center;
  padding: 5px;
  background: var(--dark-header-bg);
  width: 100%;
  z-index: 1000;
  gap: 8px;
}

.light-mode .chat-controls {
  background: var(--light-header-bg);
}

#skipBtn {
  background: var(--skip-btn);
  border: none;
  padding: 12px;
  border-radius: 25px;
  color: white;
  cursor: pointer;
  font-size: 1em;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s;
}

#skipBtn:hover {
  background: var(--skip-btn-hover);
}

.input-area {
  flex: 1;
  position: relative;
}

#msgInput {
  width: 100%;
  padding: 12px 80px 12px 15px;
  border-radius: 25px;
  border: none;
  background: var(--dark-input-bg);
  color: var(--dark-text);
  font-size: 1em;
  outline: none;
}

#msgInput:focus {
  background: var(--dark-input-focus);
}

.light-mode #msgInput {
  background: var(--light-input-bg);
  color: var(--light-text);
}

.light-mode #msgInput:focus {
  background: var(--light-input-focus);
}

.input-icons {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
}

.icon-btn {
  background: none;
  border: none;
  color: var(--dark-icon-color);
  font-size: 1.1em;
  cursor: pointer;
  transition: color 0.2s;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
}

.new-chat-btn {
  display: block;
  position: fixed;
  bottom: 75px;
  left: 0;
  right: 0;
  z-index: 1000;
  width: 90%;
  margin: 0 auto;
  padding: 10px 15px;
  background: #fff;
  color: var(--dark-header-bg);
  border: 2px solid var(--dark-header-bg);
  border-radius: 10px;
  cursor: pointer;
  font-weight: bold;
  font-size: 18px;
  font-weight: 700;
  text-align: center;
  transition: background 0.3s;
}

.new-chat-btn:hover {
  background: #ddd;
}

.icon-btn:hover { 
  color: var(--dark-text);
  background: var(--dark-icon-hover-bg);
}

.light-mode .icon-btn {
  color: var(--light-icon-color);
}

.light-mode .icon-btn:hover { 
  color: var(--light-text);
  background: var(--light-icon-hover-bg);
}

#imgInput, #gifInput { display: none; }

/* Message images */
.msg img {
  max-width: 100%;
  max-height: 300px;
  border-radius: 8px;
  margin-bottom: 5px;
}

/* System messages */
.system-msg {
  align-self: center;
  background: transparent;
  color: var(--dark-secondary-text);
  text-align: center;
  padding: 5px 0;
}

.light-mode .system-msg {
  color: var(--light-secondary-text);
}

/* Scrollbar styling */
#chatLog::-webkit-scrollbar {
  width: 8px;
}

#chatLog::-webkit-scrollbar-track {
  background: var(--dark-chat-bg);
}

#chatLog::-webkit-scrollbar-thumb {
  background: var(--dark-input-bg);
  border-radius: 4px;
}

#chatLog::-webkit-scrollbar-thumb:hover {
  background: var(--dark-input-focus);
}

.light-mode #chatLog::-webkit-scrollbar-track {
  background: var(--light-chat-bg);
}

.light-mode #chatLog::-webkit-scrollbar-thumb {
  background: var(--light-input-bg);
}

.light-mode #chatLog::-webkit-scrollbar-thumb:hover {
  background: var(--light-input-focus);
}

/* GIF search modal */
.gif-modal {
  display: none;
  position: fixed;
  bottom: 80px;
  right: 20px;
  width: 300px;
  max-height: 400px;
  background: var(--dark-msg-bg);
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  z-index: 1001;
  padding: 15px;
  overflow: hidden;
}

.light-mode .gif-modal {
  background: var(--light-msg-bg);
}

.gif-search {
  width: 100%;
  padding: 8px 12px;
  border-radius: 20px;
  border: none;
  background: var(--dark-input-bg);
  color: var(--dark-text);
  margin-bottom: 10px;
}

.light-mode .gif-search {
  background: var(--light-input-bg);
  color: var(--light-text);
}

.gif-results {
  height: 300px;
  overflow-y: auto;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
}

.gif-item {
  width: 100%;
  height: 100px;
  object-fit: cover;
  border-radius: 5px;
  cursor: pointer;
  transition: transform 0.2s;
}

.gif-item:hover {
  transform: scale(1.05);
}

.keyword-bubble {
  background-color: var(--keyword-bubble);
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 14px;
  color: var(--light-text);
  border: 1px solid var(--keyword-border);
  transition: background 0.3s;
}

#typingIndicator {
  position: absolute;
  bottom: 0;
  left: 12px;
  font-style: italic;
  color: var(--dark-secondary-text);
  display: none;
  pointer-events: none;
}

.light-mode #typingIndicator {
  color: var(--light-secondary-text);
}

/* End Image */
.system-message {
  text-align: center;
  background: none;
  padding: 12px 0;
}

.system-image img.chat-end-image {
  width: 100%;
  max-width: 600px;
  display: inline-block;
}

/* Friend System Styles */
#friendBtn {
  background: var(--friend-btn);
  color: white;
  border: none;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.3s;
}

#friendBtn:hover {
  background: var(--friend-btn-hover);
}

#friendBtn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.friend-modal {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--dark-chat-bg);
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  border: 1px solid var(--dark-header-border);
  min-width: 300px;
  z-index: 10010;
}

.light-mode .friend-modal {
  background: var(--light-chat-bg);
  color: var(--light-text);
  border: 1px solid var(--light-header-border);
}

.friend-modal h3 {
  margin-top: 0;
  margin-bottom: 10px;
}

.friend-modal-buttons {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.friend-modal-btn {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
}

#acceptFriendBtn {
  background: #4CAF50;
  color: white;
}

#rejectFriendBtn {
  background: #f44336;
  color: white;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  z-index: 10009;
}
  
/* Responsive adjustments */
@media (max-width: 600px) {
  .msg {
    max-width: 85%;
  }
  
  #skipBtn {
    padding: 15px;
    font-size: 0.9em;
  }
  
  .gif-modal {
    width: 90%;
    left: 5%;
    right: 5%;
  }

  .header-right {
    gap: 5px;
  }
  
  .friend-modal {
    width: 90%;
    max-width: 300px;
  }
}
</style>

<div class="chat-container">
<header class="app-header">
  <div class="header-left">
    <button class="menu-btn" onclick="toggleMenu()">&#9776;</button>
    <img src="logo.png" alt="TalkRush Logo" class="logo">
    <h1 class="app-title">TalkRush</h1>
  </div>
  <div class="header-right">
    <button class="header-toggle" onclick="openPreferencesModal()" title="Edit Interest">
      <i class="fas fa-pencil-alt"></i>
    </button>
    <button class="header-toggle" id="themeToggle" title="Toggle Dark/Light Mode">
      <i class="fas fa-moon"></i>
    </button>
    <button class="header-toggle" id="friendBtn" title="Add Friend">
      <i class="fas fa-user-plus"></i>
    </button>
  </div>
</header>

  <div id="chatLog"></div>
  <div id="typingIndicator">Stranger is typing...</div>

  <button id="newChatBtn" class="new-chat-btn">Start New Chat</button>
  
  <div class="chat-controls">
    <button id="skipBtn"><i class="fas fa-random"></i></button>
     <div class="input-area">
      <input type="text" id="msgInput" placeholder="Type your message..." />
      <div class="input-icons">
        <label for="imgInput" class="icon-btn" title="Send Image"><i class="fas fa-image"></i></label>
        <label for="gifInput" class="icon-btn" title="Send GIF"><i class="fas fa-film"></i></label>
        <button id="sendBtn" class="icon-btn" title="Send"><i class="fas fa-paper-plane"></i></button>
      </div>
    </div>
  </div>
  
  <input type="file" id="imgInput" accept="image/*" />
  <input type="file" id="gifInput" accept="image/gif" />
  
  <!-- GIF Search Modal -->
  <div class="gif-modal" id="gifModal">
    <input type="text" class="gif-search" id="gifSearch" placeholder="Search GIFs..." />
    <div class="gif-results" id="gifResults"></div>
  </div>
  
  <!-- Friend Request Modal -->
  <div class="friend-modal" id="friendModal">
    <h3>Friend Request</h3>
    <p id="friendRequestText">Stranger wants to add you as a friend!</p>
    <div class="friend-modal-buttons">
      <button id="acceptFriendBtn" class="friend-modal-btn">Accept</button>
      <button id="rejectFriendBtn" class="friend-modal-btn">Reject</button>
    </div>
  </div>
</div>

  <!-- Display Ads -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-7059052735946479"
       data-ad-slot="8592327962"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  
<main class="info-section" style="padding: 20px; max-width: 800px; margin: 0 auto;">

  <h1>Chat 1v1 with Strangers Online â€“ Instant & Anonymous</h1>
  <p>Connect instantly for one-on-one conversations with people worldwide. Our platform enables random, anonymous 1v1 chats where you can talk freely without registration or personal details.</p>

  <div style="max-width:600px; width:100%; margin:30px auto;">
     <img src="../assets/chat_with_strangers.gif" alt="1v1 Stranger Text and Video Chat" style="width:100%; height:auto; border-radius: 8px;">
  </div>

  <h2>How 1v1 Stranger Chat Works</h2>
  <p>Click "Start Chat" to be immediately paired with another user for a private conversation. Use "Skip" to disconnect and find a new partner instantly. Press <kbd>Esc</kbd> to quickly end a chat and move to the next stranger.</p>
  <p>Share GIFs and images during your conversation to make chats more engaging and expressive.</p>

  <h2>Features of Our 1v1 Random Chat</h2>
  <ul>
    <li><strong>Instant Anonymous Chat</strong> â€“ No sign-up, no login, no profile needed.</li>
    <li><strong>Global Random Connections</strong> â€“ Talk to people from different countries.</li>
    <li><strong>Text & Media Sharing</strong> â€“ Send text messages, images, and GIFs in real-time.</li>
    <li><strong>Gender & Interest Filters</strong> â€“ Match based on preferences and common tags.</li>
    <li><strong>Secure & Private</strong> â€“ Conversations are not stored; your identity is hidden.</li>
    <li><strong>Full Device Compatibility</strong> â€“ Works on mobile, tablet, and desktop browsers.</li>
  </ul>

  <h2>Benefits of 1v1 Chat with Strangers</h2>
  <p><strong>Talk to Strangers</strong> online to meet new people, practice languages, or find someone with similar interests. This form of <strong>random chat</strong> is popular for its spontaneity and genuine connections.</p>
  <p>Unlike group chats, a <strong>private 1 on 1 chat</strong> allows for deeper, distraction-free conversations. It's a preferred method for those seeking <strong>online friendship</strong> or casual talk.</p>

  <h2>Popular Uses for Random Video Chat and Text Chat</h2>
  <p>Users engage in <strong>free online chat</strong> for various reasons: making international friends, killing boredom, seeking advice, or simply enjoying a spontaneous conversation. The ability to <strong>share photos and GIFs</strong> adds a visual element to the interaction.</p>
  <p>Many utilize <strong>live chat</strong> platforms as a safe space for anonymous expression, discussing hobbies, culture, or daily life without social pressure.</p>

  <h2>Safety in Anonymous Chatting</h2>
  <p>While enjoying <strong>chat rooms 1v1</strong>, remember to protect your privacy. Never share personal information like your address, phone number, or financial details. Our platform provides reporting tools and moderation to maintain a respectful environment.</p>
  <p>You are in controlâ€”you can end any conversation that makes you uncomfortable and block users instantly.</p>
</main>

    <!-- Display Ads -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-7059052735946479"
       data-ad-slot="8592327962"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  
<div id="comprehensive-keywords" style="padding: 20px; max-width: 800px; margin: 20px auto 0 auto; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
  <span class="keyword-bubble">online chat</span>
  <span class="keyword-bubble">free messaging</span>
  <span class="keyword-bubble">video calls</span>
  <span class="keyword-bubble">global community</span>
  <span class="keyword-bubble">meet random people</span>
  <span class="keyword-bubble">no registration</span>
  <span class="keyword-bubble">stranger talk</span>
  <span class="keyword-bubble">instant connection</span>
  <span class="keyword-bubble">talk to strangers</span>
  <span class="keyword-bubble">random video chat</span>
  <span class="keyword-bubble">live conversations</span>
  <span class="keyword-bubble">stranger talk room</span>
  <span class="keyword-bubble">anonymous talk</span>
  <span class="keyword-bubble">social communication</span>
  <span class="keyword-bubble">omegle alternative</span>
  <span class="keyword-bubble">girls chatting website</span>
  <span class="keyword-bubble">stranger chat</span>
  <span class="keyword-bubble">random chat</span>
  <span class="keyword-bubble">online chatting with strangers free</span>
  </div>
  
</main>
  
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-7059052735946479"
     data-ad-slot="1798823861"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

{% include users-count.html %}
{% include menu.html %}
{% include scripts.html %}

<script>
const firebaseConfig = {
    databaseURL: "https://talkrush-76259-default-rtdb.asia-southeast1.firebasedatabase.app/"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const GIPHY_API_KEY = 'EKvv5S1CcXqYuHgxPNVKiNuiuNHRTzFk';

const state = {
    peer: null,
    myConn: null,
    myId: null,
    currentSystemMessage: null,
    isConnected: false,
    escPressedOnce: false,
    escTimer: null,
    currentRoomCode: null,
    typingTimeout: null,
    localStream: null,
    remoteStream: null,
    isVideoCallActive: false,
    isVideoCallRequested: false,
    isVideoCallRequestPending: false
};

const elements = {
    loadingScreen: document.getElementById("loadingScreen"),
    loadingText: document.getElementById("loadingText"),
    roomModal: document.getElementById("roomModal"),
    roomCodeDisplay: document.getElementById("roomCodeDisplay"),
    roomCodeInput: document.getElementById("roomCodeInput"),
    createRoomBtn: document.getElementById("createRoomBtn"),
    joinRoomBtn: document.getElementById("joinRoomBtn"),
    copyRoomCodeBtn: document.getElementById("copyRoomCode"),
    joinError: document.getElementById("joinError"),
    roomBtn: document.getElementById("roomBtn"),
    videoCallBtn: document.getElementById("videoCallBtn"),
    callRequestModal: document.getElementById("callRequestModal"),
    acceptCallBtn: document.getElementById("acceptCallBtn"),
    declineCallBtn: document.getElementById("declineCallBtn"),
    videoCallContainer: document.getElementById("videoCallContainer"),
    localVideo: document.getElementById("localVideo"),
    remoteVideo: document.getElementById("remoteVideo"),
    toggleVideoBtn: document.getElementById("toggleVideoBtn"),
    toggleAudioBtn: document.getElementById("toggleAudioBtn"),
    endCallBtn: document.getElementById("endCallBtn"),
    chatLog: document.getElementById("chatLog"),
    msgInput: document.getElementById("msgInput"),
    sendBtn: document.getElementById("sendBtn"),
    imgInput: document.getElementById("imgInput"),
    gifInput: document.getElementById("gifInput"),
    skipBtn: document.getElementById("skipBtn"),
    typingIndicator: document.getElementById("typingIndicator"),
    gifModal: document.getElementById("gifModal"),
    gifSearch: document.getElementById("gifSearch"),
    gifResults: document.getElementById("gifResults"),
    gifBtn: document.querySelector('[for="gifInput"]'),
    shareRoom: document.getElementById("shareRoom")
};

const utils = {
    generateRoomCode: () => Math.floor(10000 + Math.random() * 90000).toString(),
    scrollToBottom: () => elements.chatLog.scrollTop = elements.chatLog.scrollHeight,
    formatTime: () => new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
    show: (element) => element.style.display = "flex",
    showBlock: (element) => element.style.display = "block",
    hide: (element) => element.style.display = "none",
    copyToClipboard: async (text) => {
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (error) {
            console.error('Failed to copy:', error);
            return false;
        }
    }
};

const storage = {
    save: () => {
        const roomData = { roomCode: state.currentRoomCode };
        localStorage.setItem('chatRoomData', JSON.stringify(roomData));
        if (state.myId) localStorage.setItem('talkrush_peerid', state.myId);
    },
    load: () => {
        try {
            const savedPeerId = localStorage.getItem('talkrush_peerid');
            if (savedPeerId) state.myId = savedPeerId;
            
            const savedData = localStorage.getItem('chatRoomData');
            if (!savedData) return null;
            
            const data = JSON.parse(savedData);
            if (savedPeerId) data.peerId = savedPeerId;
            else if (data.peerId) localStorage.setItem('talkrush_peerid', data.peerId);
            
            return data;
        } catch (error) {
            console.error('Error loading from storage:', error);
            return null;
        }
    },
    clear: () => {
        localStorage.removeItem('chatRoomData');
        state.currentRoomCode = null;
        elements.roomCodeInput.value = '';
    },
    clearPeerId: () => {
        localStorage.removeItem('talkrush_peerid');
        state.myId = null;
    }
};

const messageHandler = {
    appendMessage: (sender, content, type = 'text') => {
        const div = document.createElement("div");
        div.className = `msg ${sender}`;
        
        if (type === 'text') div.textContent = content;
        else if (type === 'image' || type === 'gif') {
            const img = document.createElement("img");
            img.src = content;
            img.alt = type === 'gif' ? 'GIF' : 'Image';
            div.appendChild(img);
        }
        
        const time = document.createElement("div");
        time.className = "timestamp";
        time.textContent = utils.formatTime();
        div.appendChild(time);
        
        elements.chatLog.appendChild(div);
        utils.scrollToBottom();
    },
    logSystem: (msg) => {
        messageHandler.clearSystemMessage();
        const div = document.createElement("div");
        div.className = "msg system-msg";
        div.textContent = msg;
        elements.chatLog.appendChild(div);
        state.currentSystemMessage = div;
        utils.scrollToBottom();
    },
    clearSystemMessage: () => {
        if (state.currentSystemMessage?.parentNode) {
            state.currentSystemMessage.parentNode.removeChild(state.currentSystemMessage);
        }
        state.currentSystemMessage = null;
    },
    showTypingIndicator: () => {
        elements.typingIndicator.style.display = "block";
        clearTimeout(state.typingTimeout);
        state.typingTimeout = setTimeout(() => {
            elements.typingIndicator.style.display = "none";
        }, 1000);
    }
};

const roomManager = {
    createRoom: async () => {
        const code = utils.generateRoomCode();
        elements.roomCodeDisplay.textContent = code;
        utils.show(elements.loadingScreen);
        elements.loadingText.textContent = "Creating room...";
        
        try {
            const participants = {};
            participants[state.myId] = "active";
            
            await db.ref("rooms/" + code).set({
                participants: participants,
                createdAt: firebase.database.ServerValue.TIMESTAMP
            });
            
            state.currentRoomCode = code;
            storage.save();
            
            messageHandler.logSystem(`Room created with code: ${code}. Share this code with someone to chat.`);
            utils.hide(elements.roomModal);
            utils.hide(elements.loadingScreen);
            roomManager.setupParticipantListener(code);
            
        } catch (error) {
            console.error("Error creating room:", error);
            utils.hide(elements.loadingScreen);
            messageHandler.logSystem("Error creating room. Please try again.");
        }
    },
    joinRoom: async () => {
        const code = elements.roomCodeInput.value.trim();
        if (code.length !== 5) {
            roomManager.showJoinError("Room code must be 5 digits");
            return;
        }
        
        utils.show(elements.loadingScreen);
        elements.loadingText.textContent = "Joining room...";
        
        try {
            const snapshot = await db.ref("rooms/" + code).once('value');
            if (!snapshot.exists()) throw new Error("Room not found");
            
            const roomData = snapshot.val();
            if (roomData.participants && Object.keys(roomData.participants).length >= 2) {
                throw new Error("Room is full");
            }
            
            state.currentRoomCode = code;
            storage.save();
            
            await db.ref("rooms/" + code + "/participants").update({ [state.myId]: "active" });
            
            const participants = Object.keys(roomData.participants || {});
            for (const participantId of participants) {
                if (participantId !== state.myId) await connectionManager.connectToPeer(participantId);
            }
            
            utils.hide(elements.roomModal);
            utils.hide(elements.loadingScreen);
            
        } catch (error) {
            console.error("Error joining room:", error);
            utils.hide(elements.loadingScreen);
            roomManager.showJoinError(
                error.message === "Room is full" 
                    ? "Room is full. Only 2 participants allowed."
                    : "Room not found. Please check the code."
            );
        }
    },
    setupParticipantListener: (roomCode) => {
        const ref = db.ref("rooms/" + roomCode + "/participants");
        ref.on("child_added", (snapshot) => {
            if (snapshot.key !== state.myId && snapshot.val() === "active") {
                connectionManager.connectToPeer(snapshot.key);
            }
        });
        ref.on("child_removed", (snapshot) => {
            if (snapshot.key !== state.myId) messageHandler.logSystem("Participant left the room");
        });
    },
    showJoinError: (message) => {
        elements.joinError.textContent = message;
        utils.showBlock(elements.joinError);
        setTimeout(() => utils.hide(elements.joinError), 3000);
    },
    autoRejoinRoom: async () => {
        if (!state.currentRoomCode || !state.myId) {
            utils.hide(elements.loadingScreen);
            utils.showBlock(elements.roomModal);
            return;
        }
        
        utils.show(elements.loadingScreen);
        elements.loadingText.textContent = "Reconnecting to room...";
        
        try {
            const snapshot = await db.ref("rooms/" + state.currentRoomCode).once('value');
            if (!snapshot.exists()) throw new Error("Room no longer exists");
            
            const roomData = snapshot.val();
            const participants = Object.keys(roomData.participants || {});
            
            if (!participants.includes(state.myId)) {
                await db.ref("rooms/" + state.currentRoomCode + "/participants").update({ [state.myId]: "active" });
            }
            
            messageHandler.logSystem(`Reconnected to room: ${state.currentRoomCode}`);
            
            for (const participantId of participants) {
                if (participantId !== state.myId) await connectionManager.connectToPeer(participantId);
            }
            
            utils.hide(elements.loadingScreen);
            
        } catch (error) {
            console.error("Error rejoining room:", error);
            utils.hide(elements.loadingScreen);
            storage.clear();
            messageHandler.logSystem("Room no longer exists. Please create or join a new room.");
            utils.showBlock(elements.roomModal);
        }
    },
    destroyRoom: async () => {
        if (state.currentRoomCode) {
            try {
                await db.ref("rooms/" + state.currentRoomCode + "/participants/" + state.myId).remove();
                const snapshot = await db.ref("rooms/" + state.currentRoomCode + "/participants").once('value');
                if (!snapshot.exists() || Object.keys(snapshot.val()).length === 0) {
                    await db.ref("rooms/" + state.currentRoomCode).remove();
                }
            } catch (error) {
                console.error("Error leaving room:", error);
            }
        }
        storage.clear();
    }
};

const connectionManager = {
    startPeer: () => {
        messageHandler.clearSystemMessage();
        state.isConnected = false;
        if (state.peer) state.peer.destroy();
        
        const savedPeerId = state.myId;
        state.peer = new Peer(savedPeerId, {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ]
            }
        });

        state.peer.on('open', (id) => {
            state.myId = id;
            storage.save();
            utils.hide(elements.loadingScreen);
            roomManager.autoRejoinRoom();
        });

        state.peer.on('connection', connectionManager.handleNewConnection);
        state.peer.on('error', connectionManager.handlePeerError);
    },
    handlePeerError: (err) => {
        console.error('PeerJS error:', err);
        if (err.type === 'unavailable-id') {
            console.log('Peer ID unavailable, generating new one...');
            storage.clearPeerId();
            connectionManager.startPeer();
        } else {
            utils.hide(elements.loadingScreen);
            messageHandler.logSystem("Connection error. Please refresh the page to try again.");
        }
    },
    handleNewConnection: (conn) => {
        if (state.isConnected) {
            conn.close();
            return;
        }
        connectionManager.setupConnection(conn);
        messageHandler.logSystem("Connected to room participant!");
    },
    connectToPeer: async (peerId) => {
        if (state.isConnected) return;
        const conn = state.peer.connect(peerId, { reliable: true });
        conn.on('open', () => {
            connectionManager.setupConnection(conn);
            messageHandler.logSystem("Connected to room participant!");
        });
        conn.on('error', (err) => {
            console.error("Connection error:", err);
            messageHandler.logSystem("Failed to connect to participant");
        });
    },
    setupConnection: (conn) => {
        if (state.myConn) state.myConn.close();
        state.myConn = conn;
        state.isConnected = true;

        conn.on("data", connectionManager.handleData);
        conn.on("close", () => connectionManager.endConnection("Participant disconnected! ðŸ’”"));
        conn.on("error", (err) => {
            console.error("Data connection error:", err);
            connectionManager.endConnection("Connection error");
        });
    },
    handleData: (data) => {
        const handlers = {
            string: () => messageHandler.appendMessage("stranger", data),
            image: () => messageHandler.appendMessage("stranger", data.blob, 'image'),
            gif: () => messageHandler.appendMessage("stranger", data.url, 'gif'),
            typing: () => messageHandler.showTypingIndicator(),
            'video-call-request': () => videoCallManager.handleVideoCallRequest(),
            'video-call-accepted': () => videoCallManager.handleVideoCallAccepted(),
            'video-call-declined': () => videoCallManager.handleVideoCallDeclined(),
            'video-call-ended': () => videoCallManager.handleVideoCallEnded()
        };

        const handler = typeof data === 'string' ? handlers.string : handlers[data.type];
        handler?.();
    },
    endConnection: (message) => {
        messageHandler.logSystem(message);
        state.myConn = null;
        state.isConnected = false;
        videoCallManager.endVideoCall();
        if (state.currentRoomCode) {
            db.ref("rooms/" + state.currentRoomCode + "/participants/" + state.myId).remove();
        }
        setTimeout(connectionManager.startPeer, 1000);
    },
    sendMessage: () => {
        const msg = elements.msgInput.value.trim();
        if (!msg || !state.myConn || !state.isConnected) return;
        state.myConn.send(msg);
        messageHandler.appendMessage("me", msg);
        elements.msgInput.value = "";
    },
    sendFile: (file, type) => {
        if (!file || !state.myConn || !state.isConnected) return;
        const reader = new FileReader();
        reader.onload = () => {
            state.myConn.send({ type, blob: reader.result });
            messageHandler.appendMessage("me", reader.result, 'image');
        };
        reader.readAsDataURL(file);
    }
};

const videoCallManager = {
    startVideoCall: async () => {
        if (!state.isConnected || !state.myConn) {
            messageHandler.logSystem("You need to be connected to someone to start a video call");
            return;
        }
        if (state.isVideoCallActive) {
            messageHandler.logSystem("Video call is already active");
            return;
        }
        if (state.isVideoCallRequestPending) {
            messageHandler.logSystem("You already have a pending video call request");
            return;
        }
        
        try {
            state.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            state.myConn.send({ type: "video-call-request" });
            state.isVideoCallRequested = true;
            messageHandler.logSystem("Video call request sent. Waiting for response...");
            
            setTimeout(() => {
                if (!state.isVideoCallActive && state.isVideoCallRequested) {
                    messageHandler.logSystem("No response to your video call request");
                    videoCallManager.cleanupLocalStream();
                }
            }, 30000);
            
        } catch (error) {
            console.error("Error accessing camera/microphone:", error);
            messageHandler.logSystem("Could not access camera/microphone. Please check permissions.");
        }
    },
    handleVideoCallRequest: () => {
        if (state.isVideoCallActive || state.isVideoCallRequestPending) {
            state.myConn.send({ type: "video-call-declined" });
            return;
        }
        state.isVideoCallRequestPending = true;
        utils.show(elements.callRequestModal);
    },
    acceptVideoCall: () => {
        utils.hide(elements.callRequestModal);
        state.isVideoCallRequestPending = false;
        state.myConn.send({ type: "video-call-accepted" });
        videoCallManager.startVideoCallStream();
    },
    declineVideoCall: () => {
        utils.hide(elements.callRequestModal);
        state.isVideoCallRequestPending = false;
        state.myConn.send({ type: "video-call-declined" });
        messageHandler.logSystem("Video call declined");
    },
    handleVideoCallAccepted: () => {
        if (!state.isVideoCallRequested) return;
        state.isVideoCallRequested = false;
        messageHandler.logSystem("Video call accepted! Starting call...");
        videoCallManager.startVideoCallStream();
    },
    handleVideoCallDeclined: () => {
        state.isVideoCallRequested = false;
        messageHandler.logSystem("Video call was declined");
        videoCallManager.cleanupLocalStream();
    },
    startVideoCallStream: async () => {
        try {
            if (!state.localStream) {
                state.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            }
            elements.localVideo.srcObject = state.localStream;
            
            const call = state.peer.call(state.myConn.peer, state.localStream);
            call.on('stream', (remoteStream) => {
                elements.remoteVideo.srcObject = remoteStream;
                state.isVideoCallActive = true;
                utils.show(elements.videoCallContainer);
                messageHandler.logSystem("Video call started!");
            });
            call.on('close', videoCallManager.endVideoCall);
            
            state.peer.on('call', (incomingCall) => {
                incomingCall.answer(state.localStream);
                incomingCall.on('stream', (remoteStream) => {
                    elements.remoteVideo.srcObject = remoteStream;
                    state.isVideoCallActive = true;
                    utils.show(elements.videoCallContainer);
                    messageHandler.logSystem("Video call started!");
                });
            });
            
        } catch (error) {
            console.error("Error starting video call:", error);
            messageHandler.logSystem("Error starting video call");
        }
    },
    endVideoCall: () => {
        if (state.isVideoCallActive && state.myConn) {
            state.myConn.send({ type: "video-call-ended" });
        }
        videoCallManager.cleanupStreams();
        state.isVideoCallActive = false;
        state.isVideoCallRequested = false;
        state.isVideoCallRequestPending = false;
        utils.hide(elements.videoCallContainer);
        messageHandler.logSystem("Video call ended");
    },
    handleVideoCallEnded: () => {
        videoCallManager.endVideoCall();
        messageHandler.logSystem("Stranger ended the video call");
    },
    toggleVideo: () => {
        if (!state.localStream) return;
        const videoTrack = state.localStream.getVideoTracks()[0];
        if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            elements.toggleVideoBtn.innerHTML = videoTrack.enabled ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
        }
    },
    toggleAudio: () => {
        if (!state.localStream) return;
        const audioTrack = state.localStream.getAudioTracks()[0];
        if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            elements.toggleAudioBtn.innerHTML = audioTrack.enabled ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
        }
    },
    cleanupLocalStream: () => {
        if (state.localStream) {
            state.localStream.getTracks().forEach(track => track.stop());
            state.localStream = null;
        }
    },
    cleanupStreams: () => {
        videoCallManager.cleanupLocalStream();
        if (elements.remoteVideo.srcObject) {
            elements.remoteVideo.srcObject.getTracks().forEach(track => track.stop());
            elements.remoteVideo.srcObject = null;
        }
    }
};

const gifManager = {
    fetchTrendingGifs: async () => {
        try {
            const response = await fetch(`https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=20`);
            const data = await response.json();
            gifManager.displayGifs(data.data);
        } catch (error) {
            console.error("Error fetching GIFs:", error);
            messageHandler.logSystem("Failed to load GIFs");
        }
    },
    searchGifs: async (query) => {
        if (!query.trim()) {
            gifManager.fetchTrendingGifs();
            return;
        }
        try {
            const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=20`);
            const data = await response.json();
            gifManager.displayGifs(data.data);
        } catch (error) {
            console.error("Error searching GIFs:", error);
            messageHandler.logSystem("Failed to search GIFs");
        }
    },
    displayGifs: (gifs) => {
        elements.gifResults.innerHTML = "";
        gifs.forEach(gif => {
            const gifUrl = gif.images.fixed_height.url;
            const img = document.createElement("img");
            img.src = gifUrl;
            img.className = "gif-item";
            img.alt = "GIF";
            img.onclick = () => {
                if (state.myConn && state.isConnected) {
                    state.myConn.send({ type: "gif", url: gifUrl });
                    messageHandler.appendMessage("me", gifUrl, 'gif');
                    utils.hide(elements.gifModal);
                }
            };
            elements.gifResults.appendChild(img);
        });
    }
};

const eventHandlers = {
    setupEventListeners: () => {
        elements.roomBtn.onclick = () => {
            const isVisible = elements.roomModal.style.display === "block";
            utils[isVisible ? 'hide' : 'showBlock'](elements.roomModal);
            if (!isVisible && state.currentRoomCode) {
                elements.roomCodeInput.value = state.currentRoomCode;
            }
        };
        elements.createRoomBtn.onclick = roomManager.createRoom;
        elements.joinRoomBtn.onclick = roomManager.joinRoom;
        elements.copyRoomCodeBtn.onclick = async () => {
            const code = elements.roomCodeDisplay.textContent;
            if (code !== "-----" && await utils.copyToClipboard(code)) {
                const originalHtml = elements.copyRoomCodeBtn.innerHTML;
                elements.copyRoomCodeBtn.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { elements.copyRoomCodeBtn.innerHTML = originalHtml; }, 2000);
            }
        };
        elements.msgInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") connectionManager.sendMessage();
        });
        elements.msgInput.addEventListener("input", () => {
            if (state.myConn && state.isConnected) state.myConn.send({ type: "typing" });
        });
        elements.sendBtn.onclick = connectionManager.sendMessage;
        elements.imgInput.addEventListener("change", (e) => {
            connectionManager.sendFile(e.target.files[0], "image");
            e.target.value = "";
        });
        elements.gifInput.addEventListener("change", (e) => {
            connectionManager.sendFile(e.target.files[0], "image");
            e.target.value = "";
        });
        elements.skipBtn.onclick = eventHandlers.skipChat;
        elements.videoCallBtn.onclick = videoCallManager.startVideoCall;
        elements.acceptCallBtn.onclick = videoCallManager.acceptVideoCall;
        elements.declineCallBtn.onclick = videoCallManager.declineVideoCall;
        elements.endCallBtn.onclick = videoCallManager.endVideoCall;
        elements.toggleVideoBtn.onclick = videoCallManager.toggleVideo;
        elements.toggleAudioBtn.onclick = videoCallManager.toggleAudio;
        elements.gifBtn.onclick = (e) => {
            e.preventDefault();
            const isVisible = elements.gifModal.style.display === "block";
            utils[isVisible ? 'hide' : 'showBlock'](elements.gifModal);
            if (!isVisible) gifManager.fetchTrendingGifs();
        };
        elements.gifSearch.addEventListener("keypress", (e) => {
            if (e.key === "Enter") gifManager.searchGifs(elements.gifSearch.value);
        });
        elements.shareRoom.onclick = async () => {
            if (state.currentRoomCode) {
                const url = `${window.location.href.split('?')[0]}?room=${state.currentRoomCode}`;
                if (await utils.copyToClipboard(url)) {
                    messageHandler.logSystem("Room link copied to clipboard!");
                }
            } else {
                messageHandler.logSystem("Create or join a room first to share");
            }
        };
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (!state.escPressedOnce) {
                    state.escPressedOnce = true;
                    messageHandler.logSystem("Press Esc again to skip this chat and find someone new");
                    state.escTimer = setTimeout(() => {
                        state.escPressedOnce = false;
                        messageHandler.clearSystemMessage();
                    }, 3000);
                } else {
                    clearTimeout(state.escTimer);
                    state.escPressedOnce = false;
                    eventHandlers.skipChat();
                }
            }
        });
        window.addEventListener("click", (e) => {
            if (e.target === elements.gifModal) utils.hide(elements.gifModal);
        });
        window.addEventListener('beforeunload', (e) => {
            if (state.isConnected) {
                e.preventDefault();
                e.returnValue = 'Are you sure you want to leave? Your chat will be disconnected.';
            }
        });
    },
    skipChat: () => {
        if (state.myConn) state.myConn.close();
        state.isConnected = false;
        roomManager.destroyRoom();
        messageHandler.logSystem("Room destroyed. Creating a new connection...");
        setTimeout(() => {
            elements.chatLog.innerHTML = "";
            connectionManager.startPeer();
        }, 1000);
    },
    handleUrlRoomCode: () => {
        const urlParams = new URLSearchParams(window.location.search);
        const roomCodeFromUrl = urlParams.get('room');
        if (roomCodeFromUrl) {
            elements.roomCodeInput.value = roomCodeFromUrl;
            setTimeout(() => {
                if (!state.isConnected) elements.joinRoomBtn.click();
            }, 1000);
        }
    }
};

const init = () => {
    const savedData = storage.load();
    if (savedData) {
        state.currentRoomCode = savedData.roomCode;
        state.myId = savedData.peerId;
        if (state.currentRoomCode) elements.roomCodeInput.value = state.currentRoomCode;
    }
    eventHandlers.setupEventListeners();
    connectionManager.startPeer();
    eventHandlers.handleUrlRoomCode();
};

window.addEventListener('load', init);
</script>
