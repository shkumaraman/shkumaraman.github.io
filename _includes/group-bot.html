<script>
class TalkRushBot {
    constructor() {
        this.bots = new Map();
        this.isInitialized = false;
        this.botMessagesRef = null;
        this.currentGroup = null;
        this.lastUserMessage = '';
        this.lastBotResponder = '';
        this.lastProcessedTimestamp = 0;
    }

    async initialize() {
        if (this.isInitialized) return;
        try {
            await this.loadBotConfig();
            this.setupBotListener();
            this.isInitialized = true;
            console.log("ðŸ¤– TalkRushBot initialized");
        } catch (error) {
            console.error("Bot initialization failed:", error);
        }
    }

    async loadBotConfig() {
        const response = await fetch('bot.json');
        const botData = await response.json();
        this.parseBotConfig(botData);
    }

    parseBotConfig(botData) {
        for (const [botName, responses] of Object.entries(botData)) {
            const botConfig = {
                name: botName,
                triggers: [],
                cooldown: 8000,
                lastResponseTime: 0
            };

            // Convert JSON responses to trigger format
            for (const [trigger, response] of Object.entries(responses)) {
                botConfig.triggers.push({
                    trigger: this.normalizeText(trigger),
                    response: response
                });
            }

            this.bots.set(botName, botConfig);
        }
        console.log(`Loaded ${this.bots.size} bots from JSON config`);
    }

    setupBotListener() {
        this.currentGroup = this.getGroupFromURL();
        this.botMessagesRef = firebase.database()
            .ref(`groups/${this.currentGroup}/messages`)
            .orderByChild("timestamp");

        this.lastProcessedTimestamp = Date.now();

        this.botMessagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (message.timestamp > this.lastProcessedTimestamp) {
                this.processMessage(message);
            }
        });
    }

    processMessage(message) {
        if (this.isBotMessage(message)) return;
        if (!message.text || message.text.trim() === '') return;

        const messageText = this.normalizeText(message.text);
        if (this.lastUserMessage === messageText) return;

        this.lastUserMessage = messageText;

        const availableBots = Array.from(this.bots.entries()).filter(([_, cfg]) =>
            Date.now() - cfg.lastResponseTime >= cfg.cooldown
        );

        if (availableBots.length === 0) return;

        const respondingBot = this.selectRespondingBot(availableBots, messageText);
        if (!respondingBot) return;

        const [botName, botConfig] = respondingBot;
        const response = this.getPrioritySmartResponse(botConfig, messageText);

        if (response) {
            const delay = Math.random() * 4000 + 2000;
            setTimeout(() => {
                if (this.lastUserMessage === messageText) {
                    this.sendBotResponse(botName, response);
                    botConfig.lastResponseTime = Date.now();
                    this.lastBotResponder = botName;
                    this.lastProcessedTimestamp = Date.now();
                }
            }, delay);
        }
    }

    selectRespondingBot(availableBots, messageText) {
        const mentionedBot = this.getMentionedBot(messageText);
        if (mentionedBot) {
            const bot = availableBots.find(([name]) => name.toLowerCase() === mentionedBot.toLowerCase());
            if (bot) return bot;
        }

        const botsWithResponse = availableBots.filter(([_, cfg]) =>
            this.getPrioritySmartResponse(cfg, messageText)
        );
        if (botsWithResponse.length === 0) return null;

        if (this.lastBotResponder) {
            const others = botsWithResponse.filter(([n]) => n !== this.lastBotResponder);
            if (others.length > 0) {
                return others[Math.floor(Math.random() * others.length)];
            }
        }
        return botsWithResponse[Math.floor(Math.random() * botsWithResponse.length)];
    }

    getMentionedBot(messageText) {
        const botNames = Array.from(this.bots.keys());
        for (const botName of botNames) {
            if (messageText.includes(botName.toLowerCase())) {
                return botName;
            }
        }
        return null;
    }

    // --- SMART PRIORITY LOGIC (3-word â†’ 2-word â†’ 1-word fallback) ---
    getPrioritySmartResponse(botConfig, messageText) {
        const normalizedMsg = this.normalizeText(messageText);
        const words = normalizedMsg.split(' ');

        // Generate phrase chunks of length 3, 2, and 1 (priority order)
        const phraseLevels = [
            this.extractPhrases(words, 3),
            this.extractPhrases(words, 2),
            this.extractPhrases(words, 1)
        ];

        // Level-wise priority check
        for (const levelPhrases of phraseLevels) {
            for (const phrase of levelPhrases) {
                for (const { trigger, response } of botConfig.triggers) {
                    const score = this.calculateSimilarity(phrase, trigger);
                    if (score >= 0.85) {
                        return response;
                    }
                }
            }
        }

        // fallback to normal fuzzy match
        return this.getFallbackResponse(botConfig, normalizedMsg);
    }

    extractPhrases(words, size) {
        if (words.length < size) return [];
        const phrases = [];
        for (let i = 0; i <= words.length - size; i++) {
            phrases.push(words.slice(i, i + size).join(' '));
        }
        return phrases;
    }

    getFallbackResponse(botConfig, msg) {
        let bestMatch = null;
        let bestScore = 0;

        for (const { trigger, response } of botConfig.triggers) {
            const score = this.calculateSimilarity(msg, trigger);
            if (score > bestScore) {
                bestScore = score;
                bestMatch = response;
            }
        }

        return bestScore >= 0.6 ? bestMatch : null;
    }

    // --- TEXT SIMILARITY HELPERS ---
    calculateSimilarity(textA, textB) {
        const wordsA = this.normalizeText(textA).split(/\s+/);
        const wordsB = this.normalizeText(textB).split(/\s+/);

        let matches = 0;
        for (const a of wordsA) {
            if (wordsB.some(b => this.areWordsSimilar(a, b))) {
                matches++;
            }
        }
        const ratioA = matches / wordsA.length;
        const ratioB = matches / wordsB.length;
        return (ratioA + ratioB) / 2;
    }

    normalizeText(text) {
        return text.toLowerCase()
            .replace(/[^\p{L}\p{N}\s]/gu, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    areWordsSimilar(a, b) {
        if (a === b) return true;
        if (Math.abs(a.length - b.length) > 2) return false;
        let matches = 0;
        for (let i = 0; i < Math.min(a.length, b.length); i++) {
            if (a[i] === b[i]) matches++;
        }
        return (matches / Math.max(a.length, b.length)) > 0.75;
    }

    // --- FIREBASE SEND ---
    isBotMessage(message) {
        return message.nickname && this.bots.has(message.nickname);
    }

    sendBotResponse(botName, responseText) {
        const timestamp = Date.now();
        const message = {
            text: responseText,
            timestamp,
            nickname: botName
        };
        firebase.database().ref(`groups/${this.currentGroup}/messages`).push().set(message);
        console.log(`ðŸ¤– ${botName}: ${responseText}`);
    }

    getGroupFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('group') || 'general';
    }
}

window.talkRushBot = new TalkRushBot();

window.addEventListener('load', () => {
    setTimeout(() => {
        window.talkRushBot.initialize();
    }, 2000);
});
</script>
