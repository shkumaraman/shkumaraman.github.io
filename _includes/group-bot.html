<script>
class TalkRushBot {
    constructor() {
        this.bots = new Map();
        this.isInitialized = false;
        this.botMessagesRef = null;
        this.currentGroup = null;
        this.lastUserMessage = '';
        this.lastBotResponder = '';
        this.lastProcessedTimestamp = 0;
    }

    async initialize() {
        if (this.isInitialized) return;
        try {
            await this.loadBotConfig();
            this.setupBotListener();
            this.isInitialized = true;
            console.log("🤖 TalkRushBot initialized");
        } catch (error) {
            console.error("Bot initialization failed:", error);
        }
    }

    async loadBotConfig() {
        try {
            const response = await fetch('bot.txt');
            const text = await response.text();
            this.parseBotConfig(text);
        } catch (error) {
            console.error("❌ Bot config load failed:", error);
        }
    }

    parseBotConfig(configText) {
        const lines = configText.split('\n');
        let currentBot = null;
        let currentBotConfig = null;

        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;

            if (trimmed.startsWith('#')) {
                if (currentBot && currentBotConfig) {
                    this.bots.set(currentBot, currentBotConfig);
                }
                const botName = trimmed.substring(1).trim();
                currentBot = botName;
                currentBotConfig = {
                    name: botName,
                    triggers: new Map(),
                    cooldown: 8000,
                    lastResponseTime: 0
                };
            } else if (currentBotConfig && trimmed.includes('-')) {
                const parts = trimmed.split('-');
                if (parts.length >= 2) {
                    const trigger = this.normalizeText(parts[0]);
                    const response = parts.slice(1).join('-').trim();
                    if (trigger && response) {
                        currentBotConfig.triggers.set(trigger, response);
                    }
                }
            }
        }
        if (currentBot && currentBotConfig) {
            this.bots.set(currentBot, currentBotConfig);
        }
    }

    setupBotListener() {
        this.currentGroup = this.getGroupFromURL();
        this.botMessagesRef = firebase.database().ref(`groups/${this.currentGroup}/messages`).orderByChild("timestamp");

        this.lastProcessedTimestamp = Date.now();

        this.botMessagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (message.timestamp > this.lastProcessedTimestamp) {
                this.processMessage(message);
            }
        });
    }

    processMessage(message) {
        if (this.isBotMessage(message)) return;
        if (!message.text || message.text.trim() === '') return;

        const messageText = this.normalizeText(message.text);
        if (this.lastUserMessage === messageText) return;

        this.lastUserMessage = messageText;

        const availableBots = Array.from(this.bots.entries()).filter(([_, cfg]) => {
            return Date.now() - cfg.lastResponseTime >= cfg.cooldown;
        });

        if (availableBots.length === 0) return;

        const respondingBot = this.selectRespondingBot(availableBots, messageText);
        if (!respondingBot) return;

        const [botName, botConfig] = respondingBot;
        const response = this.getBotResponse(botConfig, messageText);

        if (response) {
            const delay = Math.random() * 4000 + 2000; // 2–6 sec delay
            setTimeout(() => {
                if (this.lastUserMessage === messageText) {
                    this.sendBotResponse(botName, response);
                    botConfig.lastResponseTime = Date.now();
                    this.lastBotResponder = botName;
                    this.lastProcessedTimestamp = Date.now();
                }
            }, delay);
        }
    }

    selectRespondingBot(availableBots, messageText) {
        const mentionedBot = this.getMentionedBot(messageText);
        if (mentionedBot) {
            const bot = availableBots.find(([name]) => name.toLowerCase() === mentionedBot.toLowerCase());
            if (bot) return bot;
        }

        const botsWithResponse = availableBots.filter(([_, cfg]) =>
            this.getBotResponse(cfg, messageText)
        );
        if (botsWithResponse.length === 0) return null;

        if (this.lastBotResponder) {
            const others = botsWithResponse.filter(([n]) => n !== this.lastBotResponder);
            if (others.length > 0) {
                return others[Math.floor(Math.random() * others.length)];
            }
        }
        return botsWithResponse[Math.floor(Math.random() * botsWithResponse.length)];
    }

    getMentionedBot(messageText) {
        const botNames = Array.from(this.bots.keys());
        for (const botName of botNames) {
            if (messageText.includes(botName.toLowerCase())) {
                return botName;
            }
        }
        return null;
    }

    getBotResponse(botConfig, messageText) {
        for (const [trigger, response] of botConfig.triggers) {
            if (this.isTriggerMatch(trigger, messageText)) {
                return response;
            }
        }
        return null;
    }

    // --- SMART LOGIC ---

    normalizeText(text) {
        return text
            .toLowerCase()
            .replace(/[^\p{L}\p{N}\s]/gu, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    isTriggerMatch(trigger, messageText) {
        const triggerWords = trigger.split(/\s+/);
        const msgWords = messageText.split(/\s+/);

        let matchCount = 0;
        for (const t of triggerWords) {
            if (msgWords.some(m => this.areWordsSimilar(m, t))) {
                matchCount++;
            }
        }
        return matchCount >= triggerWords.length * 0.6;
    }

    areWordsSimilar(a, b) {
        if (a === b) return true;
        if (Math.abs(a.length - b.length) > 2) return false;
        let matches = 0;
        for (let i = 0; i < Math.min(a.length, b.length); i++) {
            if (a[i] === b[i]) matches++;
        }
        const ratio = matches / Math.max(a.length, b.length);
        return ratio > 0.7;
    }

    // --- FIREBASE MESSAGE HANDLING ---

    isBotMessage(message) {
        return message.nickname && this.bots.has(message.nickname);
    }

    sendBotResponse(botName, responseText) {
        const timestamp = Date.now();
        const message = {
            text: responseText,
            timestamp,
            nickname: botName
        };
        const newMsgRef = firebase.database().ref(`groups/${this.currentGroup}/messages`).push();
        newMsgRef.set(message);
        console.log(`🤖 ${botName}: ${responseText}`);
    }

    getGroupFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('group') || 'general';
    }
}

window.talkRushBot = new TalkRushBot();

window.addEventListener('load', () => {
    setTimeout(() => {
        window.talkRushBot.initialize();
    }, 2000);
});
</script>
