<script>
  class TalkRushBot {
    constructor() {
        this.bots = new Map();
        this.isInitialized = false;
        this.botMessagesRef = null;
        this.currentGroup = null;
        this.lastUserMessage = '';
        this.lastBotResponder = '';
        this.lastProcessedTimestamp = 0;
    }

    async initialize() {
        if (this.isInitialized) return;
        
        try {
            await this.loadBotConfig();
            this.setupBotListener();
            this.isInitialized = true;
        } catch (error) {
            console.error("Bot initialization failed");
        }
    }

    async loadBotConfig() {
        try {
            const response = await fetch('bot.txt');
            const text = await response.text();
            this.parseBotConfig(text);
        } catch (error) {
            console.error("Bot config load failed");
        }
    }

    parseBotConfig(configText) {
        const lines = configText.split('\n');
        let currentBot = null;
        let currentBotConfig = null;

        for (const line of lines) {
            const trimmedLine = line.trim();
            
            if (!trimmedLine) continue;
            
            if (trimmedLine.startsWith('#')) {
                if (currentBot && currentBotConfig) {
                    this.bots.set(currentBot, currentBotConfig);
                }
                
                const botName = trimmedLine.substring(1).trim();
                currentBot = botName;
                currentBotConfig = {
                    name: botName,
                    triggers: new Map(),
                    cooldown: 8000,
                    lastResponseTime: 0
                };
            } 
            else if (currentBotConfig && trimmedLine.includes('-')) {
                const parts = trimmedLine.split('-');
                if (parts.length >= 2) {
                    const trigger = parts[0].trim().toLowerCase();
                    const response = parts.slice(1).join('-').trim();
                    
                    if (trigger && response) {
                        currentBotConfig.triggers.set(trigger, response);
                    }
                }
            }
        }
        
        if (currentBot && currentBotConfig) {
            this.bots.set(currentBot, currentBotConfig);
        }
    }

    setupBotListener() {
        this.currentGroup = this.getGroupFromURL();
        
        this.botMessagesRef = firebase.database().ref(`groups/${this.currentGroup}/messages`).orderByChild("timestamp");
        
        this.botMessagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            
            // Only process new messages (after bot initialization)
            if (message.timestamp > this.lastProcessedTimestamp) {
                this.processMessage(message);
            }
        });
        
        // Set initial timestamp to current time
        this.lastProcessedTimestamp = Date.now();
    }

    processMessage(message) {
        if (this.isBotMessage(message)) return;
        if (!message.text || message.text.trim() === '') return;
        
        const messageText = message.text.toLowerCase().trim();
        
        // Skip if same message was just processed
        if (this.lastUserMessage === messageText) return;
        this.lastUserMessage = messageText;
        
        const availableBots = Array.from(this.bots.entries()).filter(([_, config]) => {
            const now = Date.now();
            return now - config.lastResponseTime >= config.cooldown;
        });
        
        if (availableBots.length === 0) return;
        
        const respondingBot = this.selectRespondingBot(availableBots, messageText);
        if (!respondingBot) return;
        
        const [botName, botConfig] = respondingBot;
        const response = this.getBotResponse(botConfig, messageText, botName);
        
        if (response) {
            const delay = Math.random() * 5000 + 3000;
            
            setTimeout(() => {
                if (this.lastUserMessage === messageText) {
                    this.sendBotResponse(botName, response);
                    botConfig.lastResponseTime = Date.now();
                    this.lastBotResponder = botName;
                    this.lastProcessedTimestamp = Date.now();
                }
            }, delay);
        }
    }

    selectRespondingBot(availableBots, messageText) {
        const mentionedBot = this.getMentionedBot(messageText);
        if (mentionedBot) {
            const bot = availableBots.find(([name]) => name.toLowerCase() === mentionedBot.toLowerCase());
            if (bot) return bot;
        }
        
        const botsWithResponse = availableBots.filter(([_, config]) => 
            this.getBotResponse(config, messageText, config.name)
        );
        
        if (botsWithResponse.length === 0) return null;
        
        if (this.lastBotResponder) {
            const otherBots = botsWithResponse.filter(([name]) => name !== this.lastBotResponder);
            if (otherBots.length > 0) {
                return otherBots[Math.floor(Math.random() * otherBots.length)];
            }
        }
        
        return botsWithResponse[Math.floor(Math.random() * botsWithResponse.length)];
    }

    getMentionedBot(messageText) {
        const botNames = Array.from(this.bots.keys());
        for (const botName of botNames) {
            if (messageText.includes(botName.toLowerCase())) {
                return botName;
            }
        }
        return null;
    }

    getBotResponse(botConfig, messageText, botName) {
        for (const [trigger, response] of botConfig.triggers) {
            if (this.isTriggerMatch(trigger, messageText, botName)) {
                return response;
            }
        }
        return null;
    }

    isTriggerMatch(trigger, messageText, botName) {
        const words = messageText.split(/\s+/);
        const triggerWords = trigger.split(/\s+/);
        
        if (triggerWords.length === 1) {
            return messageText.includes(trigger);
        }
        
        let matchCount = 0;
        for (const tWord of triggerWords) {
            if (words.some(word => this.areWordsSimilar(word, tWord))) {
                matchCount++;
            }
        }
        
        return matchCount >= triggerWords.length * 0.6;
    }

    areWordsSimilar(word1, word2) {
        if (word1 === word2) return true;
        if (Math.abs(word1.length - word2.length) > 2) return false;
        
        const minLength = Math.min(word1.length, word2.length);
        let matchCount = 0;
        
        for (let i = 0; i < minLength; i++) {
            if (word1[i] === word2[i]) matchCount++;
        }
        
        return matchCount >= minLength * 0.7;
    }

    isBotMessage(message) {
        if (!message.nickname) return false;
        return this.bots.has(message.nickname);
    }

    sendBotResponse(botName, responseText) {
        const timestamp = Date.now();
        const message = {
            text: responseText,
            timestamp: timestamp,
            nickname: botName
        };
        
        const newMsgRef = firebase.database().ref(`groups/${this.currentGroup}/messages`).push();
        newMsgRef.set(message);
    }

    getGroupFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('group') || 'general';
    }
}

window.talkRushBot = new TalkRushBot();

window.addEventListener('load', () => {
    setTimeout(() => {
        window.talkRushBot.initialize();
    }, 2000);
});      
</script>
