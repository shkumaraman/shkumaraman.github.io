<script>
class TalkRushBot {
    constructor() {
        this.bots = new Map();
        this.isInitialized = false;
        this.botMessagesRef = null;
        this.currentGroup = null;
        this.lastUserMessage = '';
        this.lastBotResponder = '';
        this.lastProcessedTimestamp = 0;
    }

    async initialize() {
        if (this.isInitialized) return;
        try {
            await this.loadBotConfig();
            this.setupBotListener();
            this.isInitialized = true;
            console.log("ðŸ¤– TalkRushBot initialized");
        } catch (error) {
            console.error("Bot initialization failed:", error);
        }
    }

    async loadBotConfig() {
        const response = await fetch('bot.txt');
        const text = await response.text();
        this.parseBotConfig(text);
    }

    parseBotConfig(configText) {
        const lines = configText.split('\n');
        let currentBot = null;
        let currentBotConfig = null;

        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;

            if (trimmed.startsWith('#')) {
                if (currentBot && currentBotConfig) {
                    this.bots.set(currentBot, currentBotConfig);
                }
                const botName = trimmed.substring(1).trim();
                currentBot = botName;
                currentBotConfig = {
                    name: botName,
                    triggers: [],
                    cooldown: 8000,
                    lastResponseTime: 0
                };
            } else if (currentBotConfig && trimmed.includes('-')) {
                const parts = trimmed.split('-');
                if (parts.length >= 2) {
                    const trigger = this.normalizeText(parts[0]);
                    const response = parts.slice(1).join('-').trim();
                    currentBotConfig.triggers.push({ trigger, response });
                }
            }
        }
        if (currentBot && currentBotConfig) {
            this.bots.set(currentBot, currentBotConfig);
        }
    }

    setupBotListener() {
        this.currentGroup = this.getGroupFromURL();
        this.botMessagesRef = firebase.database()
            .ref(`groups/${this.currentGroup}/messages`)
            .orderByChild("timestamp");

        this.lastProcessedTimestamp = Date.now();

        this.botMessagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (message.timestamp > this.lastProcessedTimestamp) {
                this.processMessage(message);
            }
        });
    }

    processMessage(message) {
        if (this.isBotMessage(message)) return;
        if (!message.text || message.text.trim() === '') return;

        const messageText = this.normalizeText(message.text);
        if (this.lastUserMessage === messageText) return;

        this.lastUserMessage = messageText;

        const availableBots = Array.from(this.bots.entries()).filter(([_, cfg]) =>
            Date.now() - cfg.lastResponseTime >= cfg.cooldown
        );

        if (availableBots.length === 0) return;

        const respondingBot = this.selectRespondingBot(availableBots, messageText);
        if (!respondingBot) return;

        const [botName, botConfig] = respondingBot;
        const response = this.getSmartResponse(botConfig, messageText);

        if (response) {
            const delay = Math.random() * 4000 + 2000;
            setTimeout(() => {
                if (this.lastUserMessage === messageText) {
                    this.sendBotResponse(botName, response);
                    botConfig.lastResponseTime = Date.now();
                    this.lastBotResponder = botName;
                    this.lastProcessedTimestamp = Date.now();
                }
            }, delay);
        }
    }

    selectRespondingBot(availableBots, messageText) {
        const mentionedBot = this.getMentionedBot(messageText);
        if (mentionedBot) {
            const bot = availableBots.find(([name]) => name.toLowerCase() === mentionedBot.toLowerCase());
            if (bot) return bot;
        }

        const botsWithResponse = availableBots.filter(([_, cfg]) =>
            this.getSmartResponse(cfg, messageText)
        );
        if (botsWithResponse.length === 0) return null;

        if (this.lastBotResponder) {
            const others = botsWithResponse.filter(([n]) => n !== this.lastBotResponder);
            if (others.length > 0) {
                return others[Math.floor(Math.random() * others.length)];
            }
        }
        return botsWithResponse[Math.floor(Math.random() * botsWithResponse.length)];
    }

    getMentionedBot(messageText) {
        const botNames = Array.from(this.bots.keys());
        for (const botName of botNames) {
            if (messageText.includes(botName.toLowerCase())) {
                return botName;
            }
        }
        return null;
    }

    // --- SMARTER LOGIC ---
    getSmartResponse(botConfig, messageText) {
        let bestMatch = null;
        let bestScore = 0;

        for (const { trigger, response } of botConfig.triggers) {
            const score = this.calculateSimilarity(messageText, trigger);
            if (score > bestScore) {
                bestScore = score;
                bestMatch = response;
            }
        }

        // Only respond if similarity is strong enough
        if (bestScore >= 0.6) {
            return bestMatch;
        }
        return null;
    }

    calculateSimilarity(textA, textB) {
        const wordsA = this.normalizeText(textA).split(/\s+/);
        const wordsB = this.normalizeText(textB).split(/\s+/);

        let matches = 0;
        for (const a of wordsA) {
            if (wordsB.some(b => this.areWordsSimilar(a, b))) {
                matches++;
            }
        }
        const ratioA = matches / wordsA.length;
        const ratioB = matches / wordsB.length;
        return (ratioA + ratioB) / 2;
    }

    normalizeText(text) {
        return text.toLowerCase()
            .replace(/[^\p{L}\p{N}\s]/gu, '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    areWordsSimilar(a, b) {
        if (a === b) return true;
        if (Math.abs(a.length - b.length) > 2) return false;
        let matches = 0;
        for (let i = 0; i < Math.min(a.length, b.length); i++) {
            if (a[i] === b[i]) matches++;
        }
        return (matches / Math.max(a.length, b.length)) > 0.75;
    }

    // --- FIREBASE SEND ---
    isBotMessage(message) {
        return message.nickname && this.bots.has(message.nickname);
    }

    sendBotResponse(botName, responseText) {
        const timestamp = Date.now();
        const message = {
            text: responseText,
            timestamp,
            nickname: botName
        };
        firebase.database().ref(`groups/${this.currentGroup}/messages`).push().set(message);
        console.log(`ðŸ¤– ${botName}: ${responseText}`);
    }

    getGroupFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('group') || 'general';
    }
}

window.talkRushBot = new TalkRushBot();

window.addEventListener('load', () => {
    setTimeout(() => {
        window.talkRushBot.initialize();
    }, 2000);
});
</script>
