---
layout: default
no_footer: true
title: "MusicPlay"
description: "MusicPlay â€“ Listen to your favorite songs online. Search, play, shuffle, loop, and enjoy trending tracks with a fast and responsive music player."
---

<style>
  :root {
    --bg-primary: #121212;
    --bg-secondary: #1e1e1e;
    --accent-color: #1db954;
    --text-primary: #ffffff;
    --text-secondary: #bbbbbb;
    --track-height: 50px;
    --header-height: 50px;
    --tab-height: 50px;
  }
  
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
    color: var(--text-primary);
    min-height: 100vh;
    padding-top: calc(var(--header-height) + var(--tab-height) + 5px);
    padding-bottom: 180px;
    line-height: 1.6;
    position: relative;
  }
  
  /* Fixed Header */
  .header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: var(--header-height);
    display: flex;
    align-items: center;
    padding: 0 20px;
    z-index: 1000;
    background: rgba(18, 18, 18, 0.9);
    backdrop-filter: blur(5px);
  }
  
  .brand {
    font-size: 1rem;
    font-weight: 600;
    color: var(--accent-color);
  }
  
  /* Tabs */
  .tabs {
    position: fixed;
    top: var(--header-height);
    left: 0;
    right: 0;
    height: var(--tab-height);
    display: flex;
    background: rgba(18, 18, 18, 0.9);
    z-index: 1000;
    backdrop-filter: blur(5px);
  }
  
  .tab {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.3s;
    border-bottom: 3px solid transparent;
  }
  
  .tab.active {
    border-bottom: 3px solid var(--accent-color);
    color: var(--accent-color);
  }
  
  .tab-content {
    display: none;
    padding: 10px 0;
  }
  
  .tab-content.active {
    display: block;
  }
  
  .container {
    max-width: 800px;
    margin: 0 auto;
    padding: 0 20px;
  }
  
  #search-container {
    display: flex;
    margin-bottom: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    border-radius: 30px;
    overflow: hidden;
    background: var(--bg-secondary);
    height: 40px;
  }
  
  #search {
    flex: 1;
    padding: 8px 20px;
    border: none;
    background: transparent;
    color: var(--text-primary);
    font-size: 14px;
    outline: none;
  }
  
  #search::placeholder {
    color: #888;
  }
  
  #search-btn {
    background: var(--accent-color);
    color: white;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background 0.3s;
    margin: 2px;
  }
  
  .search-filters {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    overflow-x: auto;
    padding-bottom: 5px;
  }
  
  .filter-btn {
    padding: 6px 12px;
    border-radius: 15px;
    background: var(--bg-secondary);
    border: 1px solid #333;
    color: var(--text-primary);
    font-size: 12px;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.3s;
  }
  
  .filter-btn.active {
    background: var(--accent-color);
    border-color: var(--accent-color);
  }
  
  #results, #trending-results, #played-results {
    margin-top: 10px;
    max-height: calc(100vh - 350px);
    overflow-y: auto;
  }
  
  .track {
    display: flex;
    align-items: center;
    height: var(--track-height);
    margin: 8px 0;
    padding: 8px;
    background: var(--bg-secondary);
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.2s, background 0.2s;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  
  .track:hover {
    background: #2a2a2a;
    transform: translateY(-2px);
  }
  
  .track.playing {
    background: #1db95433;
    border-left: 4px solid var(--accent-color);
  }
  
  .track img {
    width: 40px;
    height: 40px;
    border-radius: 5px;
    margin-right: 12px;
    object-fit: cover;
  }
  
  .track-info {
    flex: 1;
    overflow: hidden;
  }
  
  .track-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .track-channel {
    font-size: 12px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .playlist-dropdown {
    margin: 10px 0;
    padding: 10px;
    background: var(--bg-secondary);
    border-radius: 8px;
    display: none;
  }
  
  .playlist-dropdown.active {
    display: block;
  }
  
  .playlist-track {
    display: flex;
    align-items: center;
    padding: 8px;
    border-radius: 5px;
    margin: 5px 0;
    cursor: pointer;
  }
  
  .playlist-track:hover {
    background: #2a2a2a;
  }
  
  .playlist-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #333;
  }
  
  .close-playlist {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 16px;
  }
  
  .player-section {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(30, 30, 30, 0.95);
    padding: 12px 20px;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    z-index: 1000;
  }
  
  .player-bg-thumbnail {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    opacity: 0.15;
    z-index: -1;
    filter: blur(8px);
  }
  
  .player-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 800px;
    margin: 0 auto;
  }
  
  .now-playing {
    display: flex;
    align-items: center;
    flex: 1;
    cursor: pointer;
  }
  
  .now-playing img {
    width: 45px;
    height: 45px;
    border-radius: 5px;
    margin-right: 12px;
  }
  
  .track-details {
    flex: 1;
    min-width: 0;
  }
  
  .track-name {
    font-size: 14px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .channel-name {
    font-size: 12px;
    color: var(--text-secondary);
  }
  
  .player-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 2;
  }
  
  .control-btn {
    background: none;
    border: none;
    color: var(--text-primary);
    font-size: 16px;
    margin: 0 8px;
    cursor: pointer;
    width: 35px;
    height: 35px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.3s;
  }
  
  .control-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .play-pause {
    background: var(--accent-color);
    width: 40px;
    height: 40px;
    font-size: 16px;
  }
  
  .play-pause:hover {
    background: #1ed760;
  }
  
  .player-options {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    flex: 1;
    gap: 15px;
  }
  
  #player {
    display: none;
  }
  
  .progress-container {
    width: 100%;
    height: 4px;
    background: #333;
    border-radius: 2px;
    margin-top: 8px;
    cursor: pointer;
    position: relative;
  }
  
  .progress-bar {
    height: 100%;
    background: var(--accent-color);
    border-radius: 2px;
    width: 0%;
  }
  
  .time-display {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 4px;
  }
  
  .error-message {
    background: #ff4444;
    color: white;
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    text-align: center;
  }
  
  .loading {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  
  .loading-spinner {
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top: 3px solid var(--accent-color);
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
  }
  
  /* Fullscreen player styles */
  .fullscreen-player {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
  }
  
  .fullscreen-player.active {
    opacity: 1;
    visibility: visible;
  }
  
  .fullscreen-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 2001;
  }
  
  .fullscreen-thumbnail {
    width: 80%;
    max-width: 400px;
    border-radius: 10px;
    margin-bottom: 30px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }
  
  .fullscreen-track-info {
    text-align: center;
    margin-bottom: 30px;
  }
  
  .fullscreen-track-name {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 8px;
  }
  
  .fullscreen-channel-name {
    font-size: 16px;
    color: var(--text-secondary);
  }
  
  .fullscreen-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 30px;
  }
  
  .fullscreen-control-btn {
    background: none;
    border: none;
    color: var(--text-primary);
    font-size: 20px;
    margin: 0 15px;
    cursor: pointer;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.3s;
  }
  
  .fullscreen-control-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .fullscreen-play-pause {
    background: var(--accent-color);
    width: 60px;
    height: 60px;
    font-size: 20px;
  }
  
  .fullscreen-play-pause:hover {
    background: #1ed760;
  }
  
  .fullscreen-progress-container {
    width: 80%;
    max-width: 500px;
    height: 6px;
    background: #333;
    border-radius: 3px;
    margin-bottom: 10px;
    cursor: pointer;
  }
  
  .fullscreen-progress-bar {
    height: 100%;
    background: var(--accent-color);
    border-radius: 3px;
    width: 0%;
  }
  
  .fullscreen-time-display {
    display: flex;
    justify-content: space-between;
    width: 80%;
    max-width: 500px;
    font-size: 14px;
    color: var(--text-secondary);
  }

  .fullscreen-options {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 80%;
    max-width: 500px;
    margin: 20px auto 0;
  }
  
  .mute-btn.active {
    color: var(--accent-color);
  }
  
  .auto-play-btn.active {
    color: var(--accent-color);
  }

  .inactive {
   opacity: 0.5;
   pointer-events: none;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @media (max-width: 768px) {
    .player-container {
      flex-direction: column;
      gap: 12px;
    }
    
    .now-playing, .player-controls, .player-options {
      width: 100%;
      justify-content: center;
    }
    
    .track-name {
      max-width: 150px;
    }
    
    .brand {
      font-size: 1.3rem;
    }
    
    .fullscreen-thumbnail {
      width: 90%;
    }
    
    .fullscreen-control-btn {
      margin: 0 10px;
    }
    
    .player-options {
      justify-content: center;
    }
  }
</style>

<!-- Fixed Header -->
<div class="header">
  <div class="brand">MusicPlay</div>
</div>

<!-- Tabs -->
<div class="tabs">
  <div class="tab active" data-tab="trending">Trending</div>
  <div class="tab" data-tab="search">Search</div>
  <div class="tab" data-tab="played">Played</div>
</div>

<div class="container">
  <!-- Trending Tab Content -->
  <div class="tab-content active" id="trending-tab">
    <div id="trending-results"></div>
  </div>

  <!-- Search Tab Content -->
  <div class="tab-content" id="search-tab">
    <div id="search-container">
      <input type="text" id="search" placeholder="Search for a song or artist...">
      <button id="search-btn" onclick="searchVideos()">
        <i class="fas fa-search"></i>
      </button>
    </div>
    <div class="search-filters">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="songs">Songs</button>
      <button class="filter-btn" data-filter="playlists">Playlists</button>
    </div>
    <div id="playlist-dropdown" class="playlist-dropdown"></div>
    <div id="results"></div>
  </div>

  <!-- Played Tab Content -->
  <div class="tab-content" id="played-tab">
    <div id="played-results"></div>
  </div>

  <div id="error-message" class="error-message" style="display: none;"></div>
</div>

<div class="player-section">
  <div class="player-bg-thumbnail" id="bg-thumbnail"></div>
  <div class="player-container">
    <div class="now-playing" id="open-fullscreen">
      <img id="current-thumbnail" src="https://placehold.co/600x400@2x.png" alt="Now playing">
      <div class="track-details">
        <div id="current-title" class="track-name">Nothing playing</div>
        <div id="current-channel" class="channel-name">Select a song to begin</div>
      </div>
    </div>

    <div class="player-controls">
      <button class="control-btn" onclick="shuffleTracks()" title="Shuffle">
        <i class="fas fa-random"></i>
      </button>
      <button class="control-btn" onclick="previousTrack()" title="Previous">
        <i class="fas fa-step-backward"></i>
      </button>
      <button class="control-btn play-pause" onclick="togglePlay()" title="Play/Pause" id="play-pause-btn">
        <i class="fas fa-play"></i>
      </button>
      <button class="control-btn" onclick="nextTrack()" title="Next">
        <i class="fas fa-step-forward"></i>
      </button>
      <button class="control-btn" onclick="toggleLoop()" title="Loop" id="loop-btn">
        <i class="fas fa-redo"></i>
      </button>
    </div>

    <div class="player-options">
      <button class="control-btn auto-play-btn" id="auto-play-btn" onclick="toggleAutoPlay()" title="Auto Play">
        <i class="fa-solid fa-arrow-right"></i>
      </button>
      <button class="control-btn mute-btn" id="mute-btn" onclick="toggleMute()" title="Mute">
        <i class="fas fa-volume-up"></i>
      </button>
    </div>
  </div>

  <div class="progress-container" id="progress-container">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
  <div class="time-display">
    <span id="current-time">0:00</span>
    <span id="duration">0:00</span>
  </div>
</div>

<!-- Fullscreen Player -->
<div class="fullscreen-player" id="fullscreen-player">
  <button class="fullscreen-close" onclick="closeFullscreen()">
    <i class="fas fa-times"></i>
  </button>
  <img class="fullscreen-thumbnail" id="fullscreen-thumbnail" src="https://placehold.co/600x400@2x.png" alt="Track thumbnail">
  <div class="fullscreen-track-info">
    <div class="fullscreen-track-name" id="fullscreen-track-name"></div>
    <div class="fullscreen-channel-name" id="fullscreen-channel-name"></div>
  </div>
  <div class="fullscreen-controls">
    <button class="fullscreen-control-btn" onclick="shuffleTracks()" title="Shuffle">
      <i class="fas fa-random"></i>
    </button>
    <button class="fullscreen-control-btn" onclick="previousTrack()" title="Previous">
      <i class="fas fa-step-backward"></i>
    </button>
    <button class="fullscreen-control-btn fullscreen-play-pause" onclick="togglePlay()" title="Play/Pause" id="fullscreen-play-pause-btn">
      <i class="fas fa-play"></i>
    </button>
    <button class="fullscreen-control-btn" onclick="nextTrack()" title="Next">
      <i class="fas fa-step-forward"></i>
    </button>
    <button class="fullscreen-control-btn" onclick="toggleLoop()" title="Loop" id="fullscreen-loop-btn">
      <i class="fas fa-redo"></i>
    </button>
  </div>
  <div class="fullscreen-progress-container" id="fullscreen-progress-container">
    <div class="fullscreen-progress-bar" id="fullscreen-progress-bar"></div>
  </div>
  <div class="fullscreen-time-display">
    <span id="fullscreen-current-time">0:00</span>
    <span id="fullscreen-duration">0:00</span>
  </div>
  <div class="fullscreen-options">
    <button class="fullscreen-control-btn auto-play-btn" id="fullscreen-auto-play-btn" onclick="toggleAutoPlay()" title="Auto Play">
      <i class="fa-solid fa-arrow-right"></i>
    </button>
    <button class="fullscreen-control-btn mute-btn" id="fullscreen-mute-btn" onclick="toggleMute()" title="Mute">
      <i class="fas fa-volume-up"></i>
    </button>
  </div>
</div>

<div id="player"></div>

<script>
// Global variables
var player;
var currentTrackIndex = 0;
var tracks = [];
var isShuffled = false;
var isLooping = false;
var isAutoPlay = false;
var isMuted = false;
var isPlaying = false;
var originalTracksOrder = [];
var trendingSongs = [];
var searchTimeout = null;
var currentApiKeyIndex = 0;
var apiKeys = [];
var appConfig = {};
var playedSongs = [];
var currentFilter = 'all';
var currentPlaylistId = null;
var playlistItems = [];
var currentTrackSource = null; // 'trending', 'search', 'playlist', 'played'

// Track type constants
const TRACK_TYPES = {
  TRENDING: 'trending',
  SEARCH: 'search',
  PLAYLIST: 'playlist',
  PLAYED: 'played'
};

// Load configuration from manage.json
async function loadConfig() {
    try {
        const response = await fetch('manage.json');
        appConfig = await response.json();
        
        // Set API keys
        apiKeys = appConfig.youtubeConfig.apiKeys;
        
        // Set default API key if none provided
        if (apiKeys.length === 0) {
            console.error("No API keys found in configuration");
            showError("Configuration error. Please contact administrator.");
        }
        
        // Set default volume
        if (appConfig.youtubeConfig.playerOptions && appConfig.youtubeConfig.playerOptions.volume) {
            setTimeout(() => {
                if (player && player.setVolume) {
                    player.setVolume(appConfig.youtubeConfig.playerOptions.volume);
                }
            }, 2000);
        }
    } catch (error) {
        console.error("Error loading configuration:", error);
        showError("Configuration error. Please try again later.");
    }
}

// Get current API key with rotation
function getApiKey() {
    if (apiKeys.length === 0) return null;
    
    const key = apiKeys[currentApiKeyIndex];
    
    // Rotate to next key for next request
    currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length;
    
    return key;
}

// Load YouTube iFrame API
var tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
document.body.appendChild(tag);

// Tab switching functionality
function setupTabs() {
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const tabName = tab.getAttribute('data-tab');
      
      // Update active tab
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      
      // Show corresponding content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`${tabName}-tab`).classList.add('active');
      
      // Load content based on tab
      if (tabName === 'played') {
        loadPlayedSongs();
      } else if (tabName === 'trending') {
        if (trendingSongs.length === 0) {
          loadTrendingSongs();
        }
      }
    });
  });
}

// Switch to search tab
function switchToSearchTab() {
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active');
    if (tab.getAttribute('data-tab') === 'search') {
      tab.classList.add('active');
    }
  });
  
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
    if (content.id === 'search-tab') {
      content.classList.add('active');
    }
  });
}

// Initialize player
function onYouTubeIframeAPIReady() {
  player = new YT.Player('player', {
    height: '0',
    width: '0',
    videoId: '',
    playerVars: {
      modestbranding: 1,
      controls: 0,
      rel: 0
    },
    events: {
      'onStateChange': onPlayerStateChange,
      'onReady': onPlayerReady
    }
  });
  
  // Load configuration
  loadConfig().then(() => {
    // Setup tabs
    setupTabs();
    
    // Setup search filters
    setupSearchFilters();
    
    // Load trending songs when player is ready
    loadTrendingSongs();
    
    // Add debounce to search input
    document.getElementById("search").addEventListener("input", function() {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(function() {
        if (document.getElementById("search").value.trim() !== "") {
          searchVideos();
        }
      }, 500);
    });
    
    // Add click event to open fullscreen player
    document.getElementById("open-fullscreen").addEventListener("click", openFullscreen);
    
    // Add click event to fullscreen progress bar
    document.getElementById("fullscreen-progress-container").addEventListener('click', function(e) {
      if (!player.getDuration) return;
      
      const rect = this.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const width = rect.width;
      const seekTime = (clickX / width) * player.getDuration();
      
      player.seekTo(seekTime, true);
    });
  });
}

// Setup search filter buttons
function setupSearchFilters() {
  const filterButtons = document.querySelectorAll('.filter-btn');
  filterButtons.forEach(button => {
    button.addEventListener('click', function() {
      // Update active filter
      filterButtons.forEach(btn => btn.classList.remove('active'));
      this.classList.add('active');
      
      currentFilter = this.getAttribute('data-filter');
      
      // If we have a search query, perform search with new filter
      const query = document.getElementById("search").value;
      if (query) {
        searchVideos();
      }
    });
  });
}

function onPlayerReady(event) {
  updateProgressBar();
  
  // Set initial volume from config or default to 80%
  const volume = appConfig.youtubeConfig?.playerOptions?.volume || 80;
  player.setVolume(volume);
}

function onPlayerStateChange(event) {
  if (event.data == YT.PlayerState.ENDED) {
    if (isLooping) {
      player.playVideo();
    } else if (isAutoPlay) {
      nextTrack();
    }
  }
  
  if (event.data == YT.PlayerState.PLAYING) {
    isPlaying = true;
    document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
    document.getElementById('fullscreen-play-pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
  } else if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
    isPlaying = false;
    document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-play"></i>';
    document.getElementById('fullscreen-play-pause-btn').innerHTML = '<i class="fas fa-play"></i>';
  }
  
  updateProgressBar();
}

// Cache management functions
function setCache(key, data, expiryHours = 6) {
  const now = new Date();
  const item = {
    value: data,
    expiry: now.getTime() + (expiryHours * 60 * 60 * 1000),
  };
  localStorage.setItem(key, JSON.stringify(item));
}

function getCache(key) {
  const itemStr = localStorage.getItem(key);
  if (!itemStr) return null;
  
  const item = JSON.parse(itemStr);
  const now = new Date();
  
  if (now.getTime() > item.expiry) {
    localStorage.removeItem(key);
    return null;
  }
  return item.value;
}

// Extract track info from different data structures
function extractTrackInfo(track, source) {
  let videoId, title, channel, thumbnail;
  
  switch(source) {
    case TRACK_TYPES.PLAYLIST:
      videoId = track.snippet.resourceId.videoId;
      title = track.snippet.title;
      channel = track.snippet.channelTitle;
      thumbnail = track.snippet.thumbnails.default.url;
      break;
      
    case TRACK_TYPES.PLAYED:
      if (track.id && track.id.videoId) {
        videoId = track.id.videoId;
        title = track.snippet.title;
        channel = track.snippet.channelTitle;
        thumbnail = track.snippet.thumbnails.default.url;
      } else if (track.snippet && track.snippet.resourceId && track.snippet.resourceId.videoId) {
        videoId = track.snippet.resourceId.videoId;
        title = track.snippet.title;
        channel = track.snippet.channelTitle;
        thumbnail = track.snippet.thumbnails.default.url;
      }
      break;
      
    default: // TRENDING and SEARCH
      videoId = track.id.videoId;
      title = track.snippet.title;
      channel = track.snippet.channelTitle;
      thumbnail = track.snippet.thumbnails.default.url;
  }
  
  return { videoId, title, channel, thumbnail };
}

// Create track element
function createTrackElement(track, index, source, isPlaylistItem = false) {
  const { title, channel, thumbnail } = extractTrackInfo(track, source);
  
  const trackElement = document.createElement("div");
  trackElement.className = isPlaylistItem ? "playlist-track" : "track";
  trackElement.dataset.index = index;

  const img = document.createElement("img");
  img.src = thumbnail;
  if (isPlaylistItem) {
    img.style.width = "30px";
    img.style.height = "30px";
    img.style.marginRight = "10px";
  }

  const trackInfo = document.createElement("div");
  trackInfo.className = "track-info";

  const titleDiv = document.createElement("div");
  titleDiv.className = "track-title";
  titleDiv.textContent = title;
  if (isPlaylistItem) {
    titleDiv.style.fontSize = "13px";
  }

  const channelDiv = document.createElement("div");
  channelDiv.className = "track-channel";
  channelDiv.textContent = channel;
  if (isPlaylistItem) {
    channelDiv.style.fontSize = "11px";
  }

  trackInfo.appendChild(titleDiv);
  trackInfo.appendChild(channelDiv);

  trackElement.appendChild(img);
  trackElement.appendChild(trackInfo);

  return trackElement;
}

// Save played song to history
function savePlayedSong(track, source) {
  const playedSongsStr = localStorage.getItem('playedSongs');
  let playedSongs = playedSongsStr ? JSON.parse(playedSongsStr) : [];
  
  const trackWithSource = { ...track, source: source };

  const existingIndex = playedSongs.findIndex(song => {
    if (song.id && song.id.videoId) {
      return song.id.videoId === track.id.videoId;
    } else if (song.snippet && song.snippet.resourceId && song.snippet.resourceId.videoId) {
      return song.snippet.resourceId.videoId === track.snippet.resourceId.videoId;
    }
    return false;
  });

  if (existingIndex !== -1) {
    playedSongs.splice(existingIndex, 1);
  }

  playedSongs.unshift(trackWithSource);

  // History limit manage.json se
  const limit = appConfig.youtubeConfig?.settings?.playedSongsLimit || 50;
  if (playedSongs.length > limit) {
    playedSongs = playedSongs.slice(0, limit);
  }

  localStorage.setItem('playedSongs', JSON.stringify(playedSongs));
}

// Load played songs from history
function loadPlayedSongs() {
  const playedSongsStr = localStorage.getItem('playedSongs');
  const playedSongs = playedSongsStr ? JSON.parse(playedSongsStr) : [];
  
  const playedDiv = document.getElementById("played-results");
  playedDiv.innerHTML = "";
  
  if (playedSongs.length === 0) {
    playedDiv.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No recently played songs</div>';
    return;
  }
  
  playedSongs.forEach((item, index) => {
    const trackElement = createTrackElement(item, index, TRACK_TYPES.PLAYED);
    
    trackElement.onclick = () => {
      // Set the tracks array to played songs
      tracks = playedSongs;
      originalTracksOrder = [...tracks];
      currentTrackSource = TRACK_TYPES.PLAYED;
      playTrack(index);
    };

    playedDiv.appendChild(trackElement);
  });
}

// API call with retry logic and API key rotation
async function fetchWithRetry(url, retries = 3, backoff = 300) {
  try {
    // Get API key for this request
    const apiKey = getApiKey();
    if (!apiKey) {
      throw new Error("No API keys available");
    }
    
    // Add API key to URL
    const finalUrl = url.includes('?') ? `${url}&key=${apiKey}` : `${url}?key=${apiKey}`;
    
    const response = await fetch(finalUrl);
    const data = await response.json();
    
    if (data.error && data.error.code === 403) {
      throw new Error("API quota exceeded");
    }
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return data;
  } catch (error) {
    if (retries > 0) {
      await new Promise(resolve => setTimeout(resolve, backoff));
      return fetchWithRetry(url, retries - 1, backoff * 2);
    } else {
      throw error;
    }
  }
}

// Load trending songs
async function loadTrendingSongs() {
  const cacheKey = 'trending_songs';
  const cachedData = getCache(cacheKey);
  
  if (cachedData) {
    displayTrendingSongs(cachedData);
    return;
  }
  
  try {
    document.getElementById("trending-results").innerHTML = '<div class="loading"><div class="loading-spinner"></div></div>';
    
    // Get query from config or use default
    const query = appConfig.youtubeConfig?.settings?.trendingSearchQuery || "trending hindi songs";
    
    // Get result count from config or use default
    const maxResults = appConfig.youtubeConfig?.settings?.trendingSongsCount || 7;
    
    // Build URL with region code if specified
    let url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&q=${encodeURIComponent(query)}&maxResults=${maxResults}`;
    
    if (appConfig.youtubeConfig?.settings?.regionCode) {
      url += `&regionCode=${appConfig.youtubeConfig.settings.regionCode}`;
    }
    
    if (appConfig.youtubeConfig?.settings?.hl) {
      url += `&hl=${appConfig.youtubeConfig.settings.hl}`;
    }
    
    const data = await fetchWithRetry(url);
    
    if (data.items && data.items.length > 0) {
      setCache(cacheKey, data);
      displayTrendingSongs(data);
    }
  } catch (error) {
    console.error("Error loading trending songs:", error);
    showError("Unable to load songs. Please try again later.");
    document.getElementById("trending-results").innerHTML = "";
  }
}

function displayTrendingSongs(data) {
  const trendingDiv = document.getElementById("trending-results");
  trendingDiv.innerHTML = "";
  
  trendingSongs = data.items;
  
  data.items.forEach((item, index) => {
    const trackElement = createTrackElement(item, index, TRACK_TYPES.TRENDING);
    
    trackElement.onclick = () => {
      // Set the tracks array to trending songs
      tracks = trendingSongs;
      originalTracksOrder = [...tracks];
      currentTrackSource = TRACK_TYPES.TRENDING;
      playTrack(index);
    };

    trendingDiv.appendChild(trackElement);
  });
}

// Search for videos
async function searchVideos() {
  const query = document.getElementById("search").value;
  if (!query) return;

  // Switch to search tab
  switchToSearchTab();
  
  // Check cache first
  const cacheKey = `search_${query}_${currentFilter}`;
  const cachedData = getCache(cacheKey);
  
  if (cachedData) {
    displaySearchResults(cachedData);
    return;
  }
  
  try {
    document.getElementById("results").innerHTML = '<div class="loading"><div class="loading-spinner"></div></div>';
    hideError();
    
    // Get result count from config or use default
    const maxResults = appConfig.youtubeConfig?.settings?.searchResultsCount || 7;
    
    // Build URL based on filter
    let url;
    if (currentFilter === 'playlists') {
      url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=playlist&q=${encodeURIComponent(query + " music")}&maxResults=${maxResults}`;
    } else {
      url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&q=${encodeURIComponent(query + " music")}&maxResults=${maxResults}`;
    }
    
    if (appConfig.youtubeConfig?.settings?.regionCode) {
      url += `&regionCode=${appConfig.youtubeConfig.settings.regionCode}`;
    }
    
    if (appConfig.youtubeConfig?.settings?.hl) {
      url += `&hl=${appConfig.youtubeConfig.settings.hl}`;
    }
    
    const data = await fetchWithRetry(url);
    
    if (data.items && data.items.length > 0) {
      setCache(cacheKey, data);
      displaySearchResults(data);
    }
  } catch (error) {
    console.error("Error searching videos:", error);
    
    if (error.message === "API quota exceeded") {
      showError("YouTube API quota exceeded. Please try again tomorrow.");
    } else {
      showError("Unable to search. Please check your connection and try again.");
    }
    
    document.getElementById("results").innerHTML = "";
  }
}

function displaySearchResults(data) {
  const resultsDiv = document.getElementById("results");
  resultsDiv.innerHTML = "";

  // Hide playlist dropdown
  document.getElementById('playlist-dropdown').classList.remove('active');
  currentPlaylistId = null;

  if (currentFilter === 'playlists') {
    // Display playlists
    data.items.forEach((item, index) => {
      const playlistId = item.id.playlistId;
      const title = item.snippet.title;
      const channel = item.snippet.channelTitle;
      const thumbnail = item.snippet.thumbnails.default.url;

      const trackElement = createTrackElement(item, index, TRACK_TYPES.SEARCH);
      trackElement.dataset.playlistId = playlistId;

      trackElement.onclick = () => {
        loadPlaylistItems(playlistId);
      };

      resultsDiv.appendChild(trackElement);
    });
  } else {
    // Display videos
    tracks = data.items;
    originalTracksOrder = [...tracks];
    currentTrackSource = TRACK_TYPES.SEARCH;

    data.items.forEach((item, index) => {
      const trackElement = createTrackElement(item, index, TRACK_TYPES.SEARCH);
      
      trackElement.onclick = () => {
        playTrack(index);
      };

      resultsDiv.appendChild(trackElement);
    });
  }
}

// Load playlist items
async function loadPlaylistItems(playlistId) {
  try {
    document.getElementById("playlist-dropdown").innerHTML = '<div class="loading"><div class="loading-spinner"></div></div>';
    document.getElementById("playlist-dropdown").classList.add('active');
    
    const cacheKey = `playlist_${playlistId}`;
    const cachedData = getCache(cacheKey);
    
    if (cachedData) {
      displayPlaylistItems(cachedData, playlistId);
      return;
    }
    
    const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${playlistId}&maxResults=20`;
    
    const data = await fetchWithRetry(url);
    
    if (data.items && data.items.length > 0) {
      setCache(cacheKey, data);
      displayPlaylistItems(data, playlistId);
    }
  } catch (error) {
    console.error("Error loading playlist items:", error);
    showError("Unable to load playlist. Please try again later.");
  }
}

function displayPlaylistItems(data, playlistId) {
  const playlistDropdown = document.getElementById("playlist-dropdown");
  playlistDropdown.innerHTML = "";
  
  playlistItems = data.items;
  
  // Create header with playlist title and close button
  const header = document.createElement("div");
  header.className = "playlist-header";
  
  const title = document.createElement("h3");
  title.textContent = "Playlist Tracks";
  title.style.margin = "0";
  title.style.fontSize = "14px";
  
  const closeBtn = document.createElement("button");
  closeBtn.className = "close-playlist";
  closeBtn.innerHTML = '<i class="fas fa-times"></i>';
  closeBtn.onclick = () => {
    playlistDropdown.classList.remove('active');
    currentPlaylistId = null;
  };
  
  header.appendChild(title);
  header.appendChild(closeBtn);
  playlistDropdown.appendChild(header);
  
  // Add playlist items
  data.items.forEach((item, index) => {
    const trackElement = createTrackElement(item, index, TRACK_TYPES.PLAYLIST, true);
    
    trackElement.onclick = () => {
      // Set tracks to playlist items and play
      tracks = playlistItems;
      originalTracksOrder = [...tracks];
      currentTrackSource = TRACK_TYPES.PLAYLIST;
      currentPlaylistId = playlistId;
      playTrack(index);
      
      // Close playlist dropdown
      playlistDropdown.classList.remove('active');
    };

    playlistDropdown.appendChild(trackElement);
  });
  
  currentPlaylistId = playlistId;
}

// Error handling functions
function showError(message) {
  const errorDiv = document.getElementById("error-message");
  errorDiv.textContent = message;
  errorDiv.style.display = "block";
}

function hideError() {
  document.getElementById("error-message").style.display = "none";
}

// Enable search on Enter key
document.getElementById("search").addEventListener("keypress", function(event) {
  if (event.key === "Enter") {
    clearTimeout(searchTimeout);
    searchVideos();
  }
});

// Play a specific track
function playTrack(index) {
  if (tracks.length === 0) return;
  
  // Remove playing class from all tracks
  document.querySelectorAll('.track').forEach(track => {
    track.classList.remove('playing');
  });
  
  // Add playing class to current track
  const allTracks = document.querySelectorAll('.track');
  if (allTracks[index]) {
    allTracks[index].classList.add('playing');
  }
  
  currentTrackIndex = index;
  
  const { videoId, title, channel, thumbnail } = extractTrackInfo(tracks[index], currentTrackSource);
  
  player.loadVideoById(videoId);
  
  // Update UI
  document.getElementById('current-title').textContent = title;
  document.getElementById('current-channel').textContent = channel;
  document.getElementById('current-thumbnail').src = thumbnail;
  
  // Update fullscreen player
  document.getElementById('fullscreen-track-name').textContent = title;
  document.getElementById('fullscreen-channel-name').textContent = channel;
  document.getElementById('fullscreen-thumbnail').src = thumbnail;
  
  // Set background thumbnail with blur effect
  document.getElementById('bg-thumbnail').style.backgroundImage = `url(${thumbnail})`;
  
  document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
  document.getElementById('fullscreen-play-pause-btn').innerHTML = '<i class="fas fa-pause"></i>';
  isPlaying = true;
  
  // Save to played history
  savePlayedSong(tracks[index], currentTrackSource);
}

// Toggle play/pause
function togglePlay() {
  if (!player.getVideoUrl()) {
    if (tracks.length > 0) {
      playTrack(0);
    }
    return;
  }
  
  if (isPlaying) {
    player.pauseVideo();
  } else {
    player.playVideo();
  }
}

// Play next track
function nextTrack() {
  if (tracks.length === 0) return;
  
  let nextIndex = currentTrackIndex + 1;
  if (nextIndex >= tracks.length) {
    nextIndex = 0;
  }
  
  playTrack(nextIndex);
}

// Play previous track
function previousTrack() {
  if (tracks.length === 0) return;
  
  let prevIndex = currentTrackIndex - 1;
  if (prevIndex < 0) {
    prevIndex = tracks.length - 1;
  }
  
  playTrack(prevIndex);
}

// Toggle loop
function toggleLoop() {
  isLooping = !isLooping;
  const loopBtn = document.getElementById('loop-btn');
  const fullscreenLoopBtn = document.getElementById('fullscreen-loop-btn');
  const autoPlayBtn = document.getElementById('auto-play-btn');
  const fullscreenAutoPlayBtn = document.getElementById('fullscreen-auto-play-btn');

  if (isLooping) {
    loopBtn.style.color = 'var(--accent-color)';
    fullscreenLoopBtn.style.color = 'var(--accent-color)';

    // Disable autoplay
    isAutoPlay = false;
    autoPlayBtn.classList.remove('active');
    fullscreenAutoPlayBtn.classList.remove('active');
    autoPlayBtn.classList.add('inactive');
    fullscreenAutoPlayBtn.classList.add('inactive');
  } else {
    loopBtn.style.color = '';
    fullscreenLoopBtn.style.color = '';

    // Enable autoplay button again
    autoPlayBtn.classList.remove('inactive');
    fullscreenAutoPlayBtn.classList.remove('inactive');
  }
}

// Toggle autoplay
function toggleAutoPlay() {
  isAutoPlay = !isAutoPlay;
  const autoPlayBtn = document.getElementById('auto-play-btn');
  const fullscreenAutoPlayBtn = document.getElementById('fullscreen-auto-play-btn');
  const loopBtn = document.getElementById('loop-btn');
  const fullscreenLoopBtn = document.getElementById('fullscreen-loop-btn');

  if (isAutoPlay) {
    autoPlayBtn.classList.add('active');
    fullscreenAutoPlayBtn.classList.add('active');

    // Disable loop
    isLooping = false;
    loopBtn.style.color = '';
    fullscreenLoopBtn.style.color = '';
    loopBtn.classList.add('inactive');
    fullscreenLoopBtn.classList.add('inactive');
  } else {
    autoPlayBtn.classList.remove('active');
    fullscreenAutoPlayBtn.classList.remove('active');

    // Enable loop button again
    loopBtn.classList.remove('inactive');
    fullscreenLoopBtn.classList.remove('inactive');
  }
}

// Toggle mute
function toggleMute() {
  isMuted = !isMuted;
  const muteBtn = document.getElementById('mute-btn');
  const fullscreenMuteBtn = document.getElementById('fullscreen-mute-btn');
  
  if (isMuted) {
    player.mute();
    muteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
    fullscreenMuteBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
    muteBtn.classList.add('active');
    fullscreenMuteBtn.classList.add('active');
  } else {
    player.unMute();
    muteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
    fullscreenMuteBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
    muteBtn.classList.remove('active');
    fullscreenMuteBtn.classList.remove('active');
  }
}

// Toggle shuffle
function shuffleTracks() {
  if (tracks.length === 0) return;
  
  isShuffled = !isShuffled;
  
  if (isShuffled) {
    // Shuffle the tracks array
    for (let i = tracks.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tracks[i], tracks[j]] = [tracks[j], tracks[i]];
    }
  } else {
    // Restore original order
    tracks = [...originalTracksOrder];
  }
  
  // Update the UI to reflect new order
  const resultsDiv = document.getElementById("results");
  const trendingDiv = document.getElementById("trending-results");
  const playedDiv = document.getElementById("played-results");
  
  // Clear and rebuild result lists
  if (resultsDiv.innerHTML !== "") {
    resultsDiv.innerHTML = "";
    rebuildTrackList(resultsDiv);
  }
  
  if (trendingDiv.innerHTML !== "") {
    trendingDiv.innerHTML = "";
    rebuildTrackList(trendingDiv);
  }
  
  if (playedDiv.innerHTML !== "") {
    playedDiv.innerHTML = "";
    rebuildTrackList(playedDiv);
  }
}

function rebuildTrackList(container) {
  tracks.forEach((item, index) => {
    const trackElement = createTrackElement(item, index, currentTrackSource);
    
    if (index === currentTrackIndex) {
      trackElement.classList.add("playing");
    }
    
    trackElement.onclick = () => {
      playTrack(index);
    };

    container.appendChild(trackElement);
  });
}

// Update progress bar
function updateProgressBar() {
  if (!player.getDuration) return;
  
  const progressBar = document.getElementById('progress-bar');
  const fullscreenProgressBar = document.getElementById('fullscreen-progress-bar');
  const currentTimeElement = document.getElementById('current-time');
  const durationElement = document.getElementById('duration');
  const fullscreenCurrentTimeElement = document.getElementById('fullscreen-current-time');
  const fullscreenDurationElement = document.getElementById('fullscreen-duration');
  
  const duration = player.getDuration();
  const currentTime = player.getCurrentTime();
  
  const progressPercent = (currentTime / duration) * 100;
  progressBar.style.width = `${progressPercent}%`;
  fullscreenProgressBar.style.width = `${progressPercent}%`;
  
  // Format time displays
  currentTimeElement.textContent = formatTime(currentTime);
  durationElement.textContent = formatTime(duration);
  fullscreenCurrentTimeElement.textContent = formatTime(currentTime);
  fullscreenDurationElement.textContent = formatTime(duration);
  
  if (isPlaying) {
    setTimeout(updateProgressBar, 1000);
  }
}

// Format time in minutes:seconds
function formatTime(time) {
  const minutes = Math.floor(time / 60);
  const seconds = Math.floor(time % 60);
  return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
}

// Seek functionality
document.getElementById('progress-container').addEventListener('click', function(e) {
  if (!player.getDuration) return;
  
  const rect = this.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const width = rect.width;
  const seekTime = (clickX / width) * player.getDuration();
  
  player.seekTo(seekTime, true);
});

// Fullscreen player functions
function openFullscreen() {
  if (!player.getVideoUrl()) return;
  
  document.getElementById('fullscreen-player').classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeFullscreen() {
  document.getElementById('fullscreen-player').classList.remove('active');
  document.body.style.overflow = 'auto';
}

// Close fullscreen when pressing Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    closeFullscreen();
  }
});
</script>
